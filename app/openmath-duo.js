// Generated by CoffeeScript 1.8.0
(function() {
  var OM, OMNode, exports, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof exports === "undefined" || exports === null) {
    exports = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : window;
  }

  exports.OMNode = exports.OM = OM = OMNode = (function() {
    var tokenTypes;

    OMNode.checkJSON = function(object) {
      var checkKeys, child, e, identRE, key, reason, symbol, value, variable, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _ref4;
      if (!(object instanceof Object)) {
        return "Expected an object, found " + (typeof object);
      }
      if (object.hasOwnProperty('a')) {
        _ref1 = object.a;
        for (key in _ref1) {
          if (!__hasProp.call(_ref1, key)) continue;
          value = _ref1[key];
          try {
            symbol = JSON.parse(key);
          } catch (_error) {
            e = _error;
            return "Key " + key + " invalid JSON";
          }
          if (symbol.t !== 'sy') {
            return "Key " + key + " is not a symbol";
          }
          if (reason = this.checkJSON(symbol)) {
            return reason;
          }
          if (reason = this.checkJSON(value)) {
            return reason;
          }
        }
      }
      checkKeys = function() {
        var list, _i, _len, _ref2;
        list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _ref2 = Object.keys(object);
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          if (__indexOf.call(list, key) < 0 && key !== 't' && key !== 'a') {
            return "Key " + key + " not valid in object of type " + object.t;
          }
        }
        return null;
      };
      identRE = /^[:A-Za-z_\u0374-\u03FF][:A-Za-z_\u0374-\u03FF.0-9-]*$/;
      switch (object.t) {
        case 'i':
          if (reason = checkKeys('v')) {
            return reason;
          }
          if (!/^[+-]?[0-9]+$/.test("" + object.v)) {
            return "Not an integer: " + object.v;
          }
          break;
        case 'f':
          if (reason = checkKeys('v')) {
            return reason;
          }
          if (typeof object.v !== 'number') {
            return "Not a number: " + object.v + " of type " + (typeof object.v);
          }
          if (isNaN(object.v)) {
            return 'OpenMath floats cannot be NaN';
          }
          if (!isFinite(object.v)) {
            return 'OpenMath floats must be finite';
          }
          break;
        case 'st':
          if (reason = checkKeys('v')) {
            return reason;
          }
          if (typeof object.v !== 'string') {
            return "Value for st type was " + (typeof object.v) + ", not string";
          }
          break;
        case 'ba':
          if (reason = checkKeys('v')) {
            return reason;
          }
          if (!(object.v instanceof Uint8Array)) {
            return "Value for ba type was not an instance of Uint8Array";
          }
          break;
        case 'sy':
          if (reason = checkKeys('n', 'cd', 'uri')) {
            return reason;
          }
          if (typeof object.n !== 'string') {
            return "Name for sy type was " + (typeof object.n) + ", not string";
          }
          if (typeof object.cd !== 'string') {
            return "CD for sy type was " + (typeof object.cd) + ", not string";
          }
          if ((object.uri != null) && typeof object.uri !== 'string') {
            return "URI for sy type was " + (typeof object.uri) + ", not string";
          }
          if (!identRE.test(object.n)) {
            return "Invalid identifier as symbol name: " + object.n;
          }
          if (!identRE.test(object.cd)) {
            return "Invalid identifier as symbol CD: " + object.cd;
          }
          break;
        case 'v':
          if (reason = checkKeys('n')) {
            return reason;
          }
          if (typeof object.n !== 'string') {
            return "Name for v type was " + (typeof object.n) + ", not string";
          }
          if (!identRE.test(object.n)) {
            return "Invalid identifier as variable name: " + object.n;
          }
          break;
        case 'a':
          if (reason = checkKeys('c')) {
            return reason;
          }
          if (!(object.c instanceof Array)) {
            return "Children of application object was not an array";
          }
          if (object.c.length === 0) {
            return "Application object must have at least one child";
          }
          _ref2 = object.c;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            child = _ref2[_i];
            if (reason = this.checkJSON(child)) {
              return reason;
            }
          }
          break;
        case 'bi':
          if (reason = checkKeys('s', 'v', 'b')) {
            return reason;
          }
          if (reason = this.checkJSON(object.s)) {
            return reason;
          }
          if (object.s.t !== 'sy') {
            return "Head of a binding must be a symbol";
          }
          if (!(object.v instanceof Array)) {
            return "In a binding, the v value must be an array";
          }
          _ref3 = object.v;
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            variable = _ref3[_j];
            if (reason = this.checkJSON(variable)) {
              return reason;
            }
            if (variable.t !== 'v') {
              return "In a binding, all values in the v array must have type v";
            }
          }
          if (reason = this.checkJSON(object.b)) {
            return reason;
          }
          break;
        case 'e':
          if (reason = checkKeys('s', 'c')) {
            return reason;
          }
          if (reason = this.checkJSON(object.s)) {
            return reason;
          }
          if (object.s.t !== 'sy') {
            return "Head of an error must be a symbol";
          }
          if (!(object.c instanceof Array)) {
            return "In an error, the c key must be an array";
          }
          _ref4 = object.c;
          for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
            child = _ref4[_k];
            if (reason = this.checkJSON(child)) {
              return reason;
            }
          }
          break;
        default:
          return "Invalid type: " + object.t;
      }
      return null;
    };

    OMNode.decode = function(json) {
      var e, reason, setParents;
      if (typeof json === 'string') {
        try {
          json = JSON.parse(json);
        } catch (_error) {
          e = _error;
          return e.message;
        }
      }
      if (reason = this.checkJSON(json)) {
        return reason;
      }
      setParents = function(node) {
        var c, k, v, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        _ref2 = (_ref1 = node.c) != null ? _ref1 : [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          c = _ref2[_i];
          c.p = node;
          setParents(c);
        }
        _ref4 = (_ref3 = node.v) != null ? _ref3 : [];
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          v = _ref4[_j];
          v.p = node;
          setParents(v);
        }
        _ref6 = (_ref5 = node.a) != null ? _ref5 : {};
        for (k in _ref6) {
          if (!__hasProp.call(_ref6, k)) continue;
          v = _ref6[k];
          v.p = node;
          setParents(v);
        }
        if (node.s != null) {
          node.s.p = node;
          setParents(node.s);
        }
        if (node.b != null) {
          node.b.p = node;
          return setParents(node.b);
        }
      };
      setParents(json);
      json.p = null;
      return new OMNode(json);
    };

    function OMNode(tree) {
      this.tree = tree;
      this.hasDescendantSatisfying = __bind(this.hasDescendantSatisfying, this);
      this.descendantsSatisfying = __bind(this.descendantsSatisfying, this);
      this.childrenSatisfying = __bind(this.childrenSatisfying, this);
      this.replaceFree = __bind(this.replaceFree, this);
      this.isFreeToReplace = __bind(this.isFreeToReplace, this);
      this.occursFree = __bind(this.occursFree, this);
      this.isFree = __bind(this.isFree, this);
      this.freeVariables = __bind(this.freeVariables, this);
      this.setAttribute = __bind(this.setAttribute, this);
      this.removeAttribute = __bind(this.removeAttribute, this);
      this.getAttribute = __bind(this.getAttribute, this);
      this.replaceWith = __bind(this.replaceWith, this);
      this.remove = __bind(this.remove, this);
      this.index = __bind(this.index, this);
      this.address = __bind(this.address, this);
      this.findChild = __bind(this.findChild, this);
      this.findInParent = __bind(this.findInParent, this);
      this.simpleEncode = __bind(this.simpleEncode, this);
      this.copy = __bind(this.copy, this);
      this.sameObjectAs = __bind(this.sameObjectAs, this);
      this.equals = __bind(this.equals, this);
      this.encode = __bind(this.encode, this);
      Object.defineProperty(this, 'parent', {
        get: function() {
          if (this.tree.p) {
            return new OMNode(this.tree.p);
          } else {
            return void 0;
          }
        }
      });
      Object.defineProperty(this, 'type', {
        get: function() {
          return this.tree.t;
        }
      });
      Object.defineProperty(this, 'value', {
        get: function() {
          if (this.tree.t !== 'bi') {
            return this.tree.v;
          } else {
            return void 0;
          }
        }
      });
      Object.defineProperty(this, 'name', {
        get: function() {
          return this.tree.n;
        }
      });
      Object.defineProperty(this, 'cd', {
        get: function() {
          return this.tree.cd;
        }
      });
      Object.defineProperty(this, 'uri', {
        get: function() {
          return this.tree.uri;
        }
      });
      Object.defineProperty(this, 'symbol', {
        get: function() {
          if (this.tree.s) {
            return new OMNode(this.tree.s);
          } else {
            return void 0;
          }
        }
      });
      Object.defineProperty(this, 'body', {
        get: function() {
          if (this.tree.b) {
            return new OMNode(this.tree.b);
          } else {
            return void 0;
          }
        }
      });
      Object.defineProperty(this, 'children', {
        get: function() {
          var child, _i, _len, _ref1, _ref2, _results;
          _ref2 = (_ref1 = this.tree.c) != null ? _ref1 : [];
          _results = [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            child = _ref2[_i];
            _results.push(new OMNode(child));
          }
          return _results;
        }
      });
      Object.defineProperty(this, 'variables', {
        get: function() {
          var variable, _i, _len, _ref1, _results;
          if (this.tree.t === 'bi') {
            _ref1 = this.tree.v;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              variable = _ref1[_i];
              _results.push(new OMNode(variable));
            }
            return _results;
          } else {
            return [];
          }
        }
      });
    }

    OMNode.prototype.encode = function() {
      return JSON.stringify(this.tree, function(k, v) {
        if (k === 'p') {
          return void 0;
        } else {
          return v;
        }
      });
    };

    OMNode.prototype.equals = function(other, attributes) {
      var recur;
      if (attributes == null) {
        attributes = true;
      }
      recur = function(a, b) {
        var element, index, key, value, _i, _len;
        if (a === b) {
          return true;
        }
        if (a instanceof Array || a instanceof Uint8Array) {
          if ((a instanceof Array) && (!(b instanceof Array))) {
            return false;
          }
          if ((a instanceof Uint8Array) && (!(b instanceof Uint8Array))) {
            return false;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (index = _i = 0, _len = a.length; _i < _len; index = ++_i) {
            element = a[index];
            if (!recur(element, b[index])) {
              return false;
            }
          }
          return true;
        }
        if (!(a instanceof Object)) {
          return false;
        }
        if (!(b instanceof Object)) {
          return false;
        }
        for (key in a) {
          if (!__hasProp.call(a, key)) continue;
          value = a[key];
          if (key === 'p' || !attributes && key === 'a') {
            continue;
          }
          if (!b.hasOwnProperty(key)) {
            return false;
          }
          if (!recur(value, b[key])) {
            return false;
          }
        }
        for (key in b) {
          if (!__hasProp.call(b, key)) continue;
          value = b[key];
          if (key === 'p' || !attributes && key === 'a') {
            continue;
          }
          if (!a.hasOwnProperty(key)) {
            return false;
          }
        }
        return true;
      };
      return recur(this.tree, other.tree);
    };

    OMNode.prototype.sameObjectAs = function(other) {
      return this.tree === (other != null ? other.tree : void 0);
    };

    OMNode.prototype.copy = function() {
      var recur;
      recur = function(tree) {
        var child, key, result, value, variable, _ref1, _ref2;
        result = (function() {
          switch (tree.t) {
            case 'i':
            case 'f':
            case 'st':
              return {
                t: tree.t,
                v: tree.v
              };
            case 'v':
              return {
                t: 'v',
                n: tree.n
              };
            case 'sy':
              result = {
                t: 'sy',
                n: tree.n,
                cd: tree.cd
              };
              if (tree.hasOwnProperty('uri')) {
                result.uri = tree.uri;
              }
              return result;
            case 'ba':
              return {
                t: 'ba',
                v: new Uint8Array(tree.v)
              };
            case 'e':
            case 'a':
              result = {
                t: tree.t,
                c: (function() {
                  var _i, _len, _ref1, _results;
                  _ref1 = tree.c;
                  _results = [];
                  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                    child = _ref1[_i];
                    _results.push(recur(child));
                  }
                  return _results;
                })()
              };
              if (tree.t === 'e') {
                result.s = recur(tree.s);
              }
              return result;
            case 'bi':
              return {
                t: 'bi',
                s: recur(tree.s),
                v: (function() {
                  var _i, _len, _ref1, _results;
                  _ref1 = tree.v;
                  _results = [];
                  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                    variable = _ref1[_i];
                    _results.push(recur(variable));
                  }
                  return _results;
                })(),
                b: recur(tree.b)
              };
          }
        })();
        _ref2 = (_ref1 = tree.a) != null ? _ref1 : {};
        for (key in _ref2) {
          if (!__hasProp.call(_ref2, key)) continue;
          value = _ref2[key];
          (result.a != null ? result.a : result.a = {})[key] = recur(value);
        }
        return result;
      };
      return OMNode.decode(recur(this.tree));
    };

    OMNode.integer = function(value) {
      return OMNode.decode({
        t: 'i',
        v: value
      });
    };

    OMNode.float = function(value) {
      return OMNode.decode({
        t: 'f',
        v: value
      });
    };

    OMNode.string = function(value) {
      return OMNode.decode({
        t: 'st',
        v: value
      });
    };

    OMNode.bytearray = function(value) {
      return OMNode.decode({
        t: 'ba',
        v: value
      });
    };

    OMNode.symbol = function(name, cd, uri) {
      return OMNode.decode(uri != null ? {
        t: 'sy',
        n: name,
        cd: cd,
        uri: uri
      } : {
        t: 'sy',
        n: name,
        cd: cd
      });
    };

    OMNode.variable = function(name) {
      return OMNode.decode({
        t: 'v',
        n: name
      });
    };

    OMNode.application = function() {
      var arg, args, result, _i, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      result = {
        t: 'a',
        c: []
      };
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        result.c.push(arg instanceof OMNode ? JSON.parse(arg.encode()) : arg);
      }
      return OMNode.decode(result);
    };

    OMNode.attribution = function() {
      var attrs, key, node, value;
      node = arguments[0], attrs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!(node instanceof Object)) {
        return 'Invalid first parameter to attribution';
      }
      if (attrs.length % 2 !== 0) {
        return 'Incomplete key-value pair in attribution';
      }
      if (node instanceof OMNode) {
        node = JSON.parse(node.encode());
      }
      while (attrs.length > 0) {
        if (node.a == null) {
          node.a = {};
        }
        key = attrs.shift();
        key = key instanceof OMNode ? key.encode() : JSON.stringify(key);
        value = attrs.shift();
        node.a[key] = value instanceof OMNode ? JSON.parse(value.encode()) : value;
      }
      return OMNode.decode(node);
    };

    OMNode.binding = function() {
      var body, head, result, variable, vars, _i, _j, _len;
      head = arguments[0], vars = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), body = arguments[_i++];
      if (!(head instanceof Object)) {
        return 'Invalid first parameter to binding';
      }
      if (!(body instanceof Object)) {
        return 'Invalid last parameter to binding';
      }
      result = {
        t: 'bi',
        s: head instanceof OMNode ? JSON.parse(head.encode()) : head,
        v: [],
        b: body instanceof OMNode ? JSON.parse(body.encode()) : body
      };
      for (_j = 0, _len = vars.length; _j < _len; _j++) {
        variable = vars[_j];
        result.v.push(variable instanceof OMNode ? JSON.parse(variable.encode()) : variable);
      }
      return OMNode.decode(result);
    };

    OMNode.error = function() {
      var head, other, others, result, _i, _len;
      head = arguments[0], others = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!(head instanceof Object)) {
        return 'Invalid first parameter to binding';
      }
      result = {
        t: 'e',
        s: head instanceof OMNode ? JSON.parse(head.encode()) : head,
        c: []
      };
      for (_i = 0, _len = others.length; _i < _len; _i++) {
        other = others[_i];
        result.c.push(other instanceof OMNode ? JSON.parse(other.encode()) : other);
      }
      return OMNode.decode(result);
    };

    tokenTypes = [
      {
        name: 'symbol',
        pattern: /[:A-Za-z_][:A-Za-z_0-9-]*\.[:A-Za-z_][:A-Za-z_0-9-]*/
      }, {
        name: 'variable',
        pattern: /[:A-Za-z_][:A-Za-z_0-9-]*/
      }, {
        name: 'float',
        pattern: /[+-]?(?:[0-9]+\.[0-9]*|[0-9]*\.[0-9]+)/
      }, {
        name: 'integer',
        pattern: /[+-]?[0-9]+/
      }, {
        name: 'string',
        pattern: /"(?:[^"\\]|\\"|\\\\)*"|'(?:[^'\\]|\\'|\\\\)*'/
      }, {
        name: 'comma',
        pattern: /,/
      }, {
        name: 'openParen',
        pattern: /\(/
      }, {
        name: 'closeParen',
        pattern: /\)/
      }, {
        name: 'openBracket',
        pattern: /\[/
      }, {
        name: 'closeBracket',
        pattern: /\]/
      }
    ];

    OMNode.simpleDecode = function(input) {
      var children, expr, halves, i, index, int, match, next, originally, stack, state, tokenType, tokens, type, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref1;
      if (typeof input !== 'string') {
        return 'Input was not a string';
      }
      tokens = [];
      while (input.length > 0) {
        originally = input.length;
        for (_i = 0, _len = tokenTypes.length; _i < _len; _i++) {
          tokenType = tokenTypes[_i];
          match = tokenType.pattern.exec(input);
          if ((match != null) && match.index === 0) {
            tokens.push({
              type: tokenType.name,
              text: match[0]
            });
            input = input.slice(match[0].length);
          }
        }
        if (input.length === originally) {
          return "Could not understand from here: " + input.slice(0, 11);
        }
      }
      state = 'expression about to start';
      stack = [];
      while (tokens.length > 0) {
        next = tokens.shift();
        switch (state) {
          case 'expression about to start':
            switch (next.type) {
              case 'symbol':
                halves = next.text.split('.');
                stack.unshift({
                  node: OMNode.symbol(halves[1], halves[0])
                });
                break;
              case 'variable':
                stack.unshift({
                  node: OMNode.variable(next.text)
                });
                break;
              case 'integer':
                int = parseInt(next.text);
                if (/\./.test(int)) {
                  int = next.text;
                }
                stack.unshift({
                  node: OMNode.integer(int)
                });
                break;
              case 'float':
                stack.unshift({
                  node: OMNode.float(parseFloat(next.text))
                });
                break;
              case 'string':
                type = next.text[0];
                next = next.text.slice(1, -1).replace(RegExp("\\\\" + type, 'g'), type);
                stack.unshift({
                  node: OMNode.string(next)
                });
                break;
              default:
                return "Unexpected " + next.text;
            }
            state = 'expression ended';
            break;
          case 'expression ended':
            switch (next.type) {
              case 'comma':
                state = 'expression about to start';
                break;
              case 'openParen':
                stack[0].head = 'application';
                if ((tokens != null ? (_ref1 = tokens[0]) != null ? _ref1.type : void 0 : void 0) === 'closeParen') {
                  tokens.shift();
                  stack.unshift({
                    node: OMNode.application(stack.shift().node)
                  });
                  state = 'expression ended';
                } else {
                  state = 'expression about to start';
                }
                break;
              case 'openBracket':
                stack[0].head = 'binding';
                state = 'expression about to start';
                break;
              case 'closeParen':
                for (index = _j = 0, _len1 = stack.length; _j < _len1; index = ++_j) {
                  expr = stack[index];
                  if (expr.head === 'application') {
                    break;
                  }
                  if (expr.head === 'binding') {
                    return "Mismatch: [ closed by )";
                  }
                }
                if (index === stack.length) {
                  return "Unexpected )";
                }
                children = [];
                for (i = _k = 0; 0 <= index ? _k <= index : _k >= index; i = 0 <= index ? ++_k : --_k) {
                  children.unshift(stack.shift().node);
                }
                stack.unshift({
                  node: OMNode.application.apply(null, children)
                });
                break;
              case 'closeBracket':
                for (index = _l = 0, _len2 = stack.length; _l < _len2; index = ++_l) {
                  expr = stack[index];
                  if (expr.head === 'binding') {
                    break;
                  }
                  if (expr.head === 'application') {
                    return "Mismatch: ( closed by ]";
                  }
                }
                if (index === stack.length) {
                  return "Unexpected ]";
                }
                children = [];
                for (i = _m = 0; 0 <= index ? _m <= index : _m >= index; i = 0 <= index ? ++_m : --_m) {
                  children.unshift(stack.shift().node);
                }
                stack.unshift({
                  node: OMNode.binding.apply(null, children)
                });
                break;
              default:
                return "Unexpected " + next.text;
            }
        }
        if (typeof (stack != null ? stack[0].node : void 0) === 'string') {
          return stack[0].node;
        }
      }
      if (stack.length > 1) {
        return "Unexpected end of input";
      } else {
        return stack[0].node;
      }
    };

    OMNode.prototype.simpleEncode = function() {
      var recur;
      recur = function(tree) {
        var body, c, children, head, v, variables;
        switch (tree != null ? tree.t : void 0) {
          case 'i':
          case 'f':
            return "" + tree.v;
          case 'v':
            return tree.n;
          case 'st':
            return "'" + (tree.v.replace(/'/g, '\\\'')) + "'";
          case 'sy':
            return "" + tree.cd + "." + tree.n;
          case 'ba':
            return "'byte array'";
          case 'e':
            return "'error'";
          case 'a':
            children = (function() {
              var _i, _len, _ref1, _results;
              _ref1 = tree.c;
              _results = [];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                c = _ref1[_i];
                _results.push(recur(c));
              }
              return _results;
            })();
            head = children.shift();
            return "" + head + "(" + (children.join(',')) + ")";
          case 'bi':
            variables = (function() {
              var _i, _len, _ref1, _results;
              _ref1 = tree.v;
              _results = [];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                v = _ref1[_i];
                _results.push(recur(v));
              }
              return _results;
            })();
            head = recur(tree.s);
            body = recur(tree.b);
            return "" + head + "[" + (variables.join(',')) + "," + body + "]";
          default:
            return "Error: Invalid OpenMath type " + (tree != null ? tree.t : void 0);
        }
      };
      return recur(this.tree);
    };

    OMNode.prototype.findInParent = function() {
      var child, index, key, value, variable, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
      if (!this.parent) {
        return void 0;
      }
      _ref1 = this.parent.children;
      for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
        child = _ref1[index];
        if (this.sameObjectAs(child)) {
          return "c" + index;
        }
      }
      if (this.type === 'v') {
        _ref2 = this.parent.variables;
        for (index = _j = 0, _len1 = _ref2.length; _j < _len1; index = ++_j) {
          variable = _ref2[index];
          if (this.sameObjectAs(variable)) {
            return "v" + index;
          }
        }
      }
      if (this.sameObjectAs(this.parent.symbol)) {
        return 's';
      }
      if (this.sameObjectAs(this.parent.body)) {
        return 'b';
      }
      _ref4 = (_ref3 = this.parent.tree.a) != null ? _ref3 : {};
      for (key in _ref4) {
        if (!__hasProp.call(_ref4, key)) continue;
        value = _ref4[key];
        if (this.tree === value) {
          return key;
        }
      }
      return void 0;
    };

    OMNode.prototype.findChild = function(indexInParent) {
      switch (indexInParent[0]) {
        case 'c':
          return this.children[parseInt(indexInParent.slice(1))];
        case 'v':
          return this.variables[parseInt(indexInParent.slice(1))];
        case 's':
          return this.symbol;
        case 'b':
          return this.body;
        case '{':
          return this.getAttribute(OMNode.decode(indexInParent));
      }
    };

    OMNode.prototype.address = function(inThis) {
      if (!this.parent || this.sameObjectAs(inThis)) {
        return [];
      }
      return this.parent.address(inThis).concat([this.findInParent()]);
    };

    OMNode.prototype.index = function(address) {
      var _ref1;
      if (!(address instanceof Array)) {
        return void 0;
      }
      if (address.length === 0) {
        return this;
      }
      return (_ref1 = this.findChild(address[0])) != null ? _ref1.index(address.slice(1)) : void 0;
    };

    OMNode.prototype.remove = function() {
      var index;
      if (!(index = this.findInParent())) {
        return;
      }
      switch (index[0]) {
        case 'c':
          this.parent.tree.c.splice(parseInt(index.slice(1)), 1);
          break;
        case 'v':
          this.parent.tree.v.splice(parseInt(index.slice(1)), 1);
          break;
        case 'b':
          delete this.parent.tree.b;
          break;
        case 's':
          delete this.parent.tree.s;
          break;
        case '{':
          delete this.parent.tree.a[index];
      }
      return delete this.tree.p;
    };

    OMNode.prototype.replaceWith = function(other) {
      var index, original;
      if (this.sameObjectAs(other)) {
        return;
      }
      index = this.findInParent();
      if (index === 's' && other.type !== 'sy') {
        return;
      }
      if ((index != null ? index[0] : void 0) === 'v' && other.type !== 'v') {
        return;
      }
      other.remove();
      original = new OMNode(this.tree);
      this.tree = other.tree;
      switch (index != null ? index[0] : void 0) {
        case 'c':
          original.parent.tree.c[parseInt(index.slice(1))] = this.tree;
          break;
        case 'v':
          original.parent.tree.v[parseInt(index.slice(1))] = this.tree;
          break;
        case 'b':
          original.parent.tree.b = this.tree;
          break;
        case 's':
          original.parent.tree.s = this.tree;
          break;
        case '{':
          original.parent.tree.a[index] = this.tree;
          break;
        default:
          return;
      }
      this.tree.p = original.tree.p;
      delete original.tree.p;
      return original;
    };

    OMNode.prototype.getAttribute = function(keySymbol) {
      var cdRE, key, nameRE, value, _ref1, _ref2;
      if (!(keySymbol instanceof OMNode)) {
        return void 0;
      }
      if (keySymbol.type !== 'sy') {
        return void 0;
      }
      nameRE = RegExp("\"n\":\"" + keySymbol.name + "\"");
      cdRE = RegExp("\"cd\":\"" + keySymbol.cd + "\"");
      _ref2 = (_ref1 = this.tree.a) != null ? _ref1 : {};
      for (key in _ref2) {
        if (!__hasProp.call(_ref2, key)) continue;
        value = _ref2[key];
        if (nameRE.test(key) && cdRE.test(key)) {
          return new OMNode(value);
        }
      }
    };

    OMNode.prototype.removeAttribute = function(keySymbol) {
      var cdRE, key, nameRE, value, _ref1, _ref2;
      if (!(keySymbol instanceof OMNode)) {
        return;
      }
      if (keySymbol.type !== 'sy') {
        return;
      }
      nameRE = RegExp("\"n\":\"" + keySymbol.name + "\"");
      cdRE = RegExp("\"cd\":\"" + keySymbol.cd + "\"");
      _ref2 = (_ref1 = this.tree.a) != null ? _ref1 : {};
      for (key in _ref2) {
        if (!__hasProp.call(_ref2, key)) continue;
        value = _ref2[key];
        if (nameRE.test(key) && cdRE.test(key)) {
          (new OMNode(value)).remove();
          delete this.tree.a[key];
          return;
        }
      }
    };

    OMNode.prototype.setAttribute = function(keySymbol, newValue) {
      var _base;
      if (!(keySymbol instanceof OMNode) || !(newValue instanceof OMNode)) {
        return;
      }
      if (keySymbol.type !== 'sy') {
        return;
      }
      this.removeAttribute(keySymbol);
      newValue.remove();
      ((_base = this.tree).a != null ? _base.a : _base.a = {})[keySymbol.encode()] = newValue.tree;
      return newValue.tree.p = this.tree;
    };

    OMNode.prototype.freeVariables = function() {
      var boundByThis, child, free, result, v, varname, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _results;
      switch (this.type) {
        case 'v':
          return [this.name];
        case 'a':
        case 'c':
          result = [];
          _ref1 = this.children;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            child = _ref1[_i];
            _ref2 = child.freeVariables();
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              free = _ref2[_j];
              if (__indexOf.call(result, free) < 0) {
                result.push(free);
              }
            }
          }
          return result;
        case 'bi':
          boundByThis = (function() {
            var _k, _len2, _ref3, _results;
            _ref3 = this.variables;
            _results = [];
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
              v = _ref3[_k];
              _results.push(v.name);
            }
            return _results;
          }).call(this);
          _ref3 = this.body.freeVariables();
          _results = [];
          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
            varname = _ref3[_k];
            if (__indexOf.call(boundByThis, varname) < 0) {
              _results.push(varname);
            }
          }
          return _results;
        default:
          return [];
      }
    };

    OMNode.prototype.isFree = function(inThis) {
      var boundHere, freeVariables, v, variable, walk, _i, _len;
      freeVariables = this.freeVariables();
      walk = this;
      while (walk) {
        if (walk.type === 'bi') {
          boundHere = (function() {
            var _i, _len, _ref1, _results;
            _ref1 = walk.variables;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              v = _ref1[_i];
              _results.push(v.name);
            }
            return _results;
          })();
          for (_i = 0, _len = freeVariables.length; _i < _len; _i++) {
            variable = freeVariables[_i];
            if (__indexOf.call(boundHere, variable) >= 0) {
              return false;
            }
          }
        }
        if (walk.sameObjectAs(inThis)) {
          break;
        }
        walk = walk.parent;
      }
      return true;
    };

    OMNode.prototype.occursFree = function(findThis) {
      var child, _i, _len, _ref1, _ref2, _ref3;
      if (this.equals(findThis) && this.isFree()) {
        return true;
      }
      if ((_ref1 = this.symbol) != null ? _ref1.equals(findThis) : void 0) {
        return true;
      }
      if ((_ref2 = this.body) != null ? _ref2.occursFree(findThis) : void 0) {
        return true;
      }
      _ref3 = this.children;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        child = _ref3[_i];
        if (child.occursFree(findThis)) {
          return true;
        }
      }
      return false;
    };

    OMNode.prototype.isFreeToReplace = function(subtreeToReplace, inThis) {
      var context, result, saved;
      if (this.sameObjectAs(subtreeToReplace)) {
        return true;
      }
      if (subtreeToReplace.parent == null) {
        return true;
      }
      context = subtreeToReplace;
      while (context.parent) {
        context = context.parent;
      }
      saved = new OMNode(subtreeToReplace.tree);
      if (!subtreeToReplace.replaceWith(this.copy())) {
        return false;
      }
      result = subtreeToReplace.isFree(inThis);
      subtreeToReplace.replaceWith(saved);
      return result;
    };

    OMNode.prototype.replaceFree = function(original, replacement, inThis) {
      var child, save, variable, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _results;
      if (inThis == null) {
        inThis = this;
      }
      if (this.isFree(inThis) && this.equals(original)) {
        save = new OMNode(this.tree);
        this.replaceWith(replacement.copy());
        if (!this.isFree(inThis)) {
          this.replaceWith(save);
        }
        return;
      }
      if ((_ref1 = this.symbol) != null) {
        _ref1.replaceFree(original, replacement, inThis);
      }
      if ((_ref2 = this.body) != null) {
        _ref2.replaceFree(original, replacement, inThis);
      }
      _ref3 = this.variables;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        variable = _ref3[_i];
        variable.replaceFree(original, replacement, inThis);
      }
      _ref4 = this.children;
      _results = [];
      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
        child = _ref4[_j];
        _results.push(child.replaceFree(original, replacement, inThis));
      }
      return _results;
    };

    OMNode.prototype.childrenSatisfying = function(filter) {
      var child, children, _i, _len, _results;
      if (filter == null) {
        filter = function() {
          return true;
        };
      }
      children = this.children;
      if (this.symbol != null) {
        children.push(this.symbol);
      }
      children = children.concat(this.variables);
      if (this.body != null) {
        children.push(this.body);
      }
      _results = [];
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        child = children[_i];
        if (filter(child)) {
          _results.push(child);
        }
      }
      return _results;
    };

    OMNode.prototype.descendantsSatisfying = function(filter) {
      var child, results, _i, _len, _ref1;
      if (filter == null) {
        filter = function() {
          return true;
        };
      }
      results = [];
      if (filter(this)) {
        results.push(this);
      }
      _ref1 = this.childrenSatisfying();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        child = _ref1[_i];
        results = results.concat(child.descendantsSatisfying(filter));
      }
      return results;
    };

    OMNode.prototype.hasDescendantSatisfying = function(filter) {
      var child, _i, _len, _ref1;
      if (filter == null) {
        filter = function() {
          return true;
        };
      }
      if (filter(this)) {
        return true;
      }
      _ref1 = this.childrenSatisfying();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        child = _ref1[_i];
        if (child.hasDescendantSatisfying(filter)) {
          return true;
        }
      }
      return false;
    };

    return OMNode;

  })();

  OM.int = OM.integer;

  OM.flo = OM.float;

  OM.str = OM.string;

  OM.byt = OM.bytearray;

  OM.sym = OM.symbol;

  OM["var"] = OM.variable;

  OM.app = OM.application;

  OM.att = OM.attribution;

  OM.bin = OM.binding;

  OM.err = OM.error;

  OM.simple = OM.simpleDecode;

}).call(this);

//# sourceMappingURL=openmath-duo.js.map
