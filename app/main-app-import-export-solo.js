// Generated by CoffeeScript 1.8.0
(function() {
  var appIsRunningOnGitHub, translateShorthandIntoEditor,
    __slice = [].slice;

  window.groupMenuItems.wikiimport = {
    text: 'Import from wiki...',
    context: 'file',
    onclick: function() {
      var pageName;
      if (appIsRunningOnGitHub()) {
        return;
      }
      pageName = prompt('Give the name of the page to import (case sensitive)', 'Main Page');
      if (pageName === null) {
        return;
      }
      return tinymce.activeEditor.MediaWiki.importPage(pageName, function(document, metadata) {
        if (metadata != null) {
          return tinymce.activeEditor.Settings.document.metadata = metadata;
        }
      });
    }
  };

  window.groupMenuItems.wikiexport = {
    text: 'Export to wiki',
    context: 'file',
    onclick: function() {
      var loginCallback, pageName, password, postCallback, username;
      if (appIsRunningOnGitHub()) {
        return;
      }
      pageName = tinymce.activeEditor.Settings.document.get('wiki_title');
      if (pageName == null) {
        tinymce.activeEditor.Dialogs.alert({
          title: 'Page Title not set',
          message: '<p>You have not yet set the title under which this document should be published on the wiki. See the document settings on the File menu.</p>'
        });
        return;
      }
      username = tinymce.activeEditor.Settings.application.get('wiki_username');
      password = tinymce.activeEditor.Settings.application.get('wiki_password');
      if ((username == null) || (password == null)) {
        tinymce.activeEditor.Dialogs.alert({
          title: 'No Wiki Credentials',
          message: '<p>You have not given your wiki username and password to the application settings.  See the application settings on the File menu.</p>'
        });
        return;
      }
      postCallback = function(result, error) {
        var match, url;
        if (error) {
          tinymce.activeEditor.Dialogs.alert({
            title: 'Posting Error',
            message: "<p>Error when posting to the wiki:</p> <p>" + error + "</p>"
          });
          return;
        }
        match = /^[^/]+\/\/[^/]+\//.exec(window.location.href);
        url = window.location.href.slice(0, match[0].length) + 'wiki/index.php?title=' + encodeURIComponent(pageName);
        return tinymce.activeEditor.Dialogs.alert({
          title: 'Document Posted',
          message: "<p>Posting succeeded.</p> <p><a href='" + url + "' target='_blank'>Visit posted page.</a></p>"
        });
      };
      loginCallback = function(result, error) {
        var content;
        if (error) {
          tinymce.activeEditor.Dialogs.alert({
            title: 'Wiki Login Error',
            message: "<p>Error when logging into the wiki:</p> <p>" + error + "</p>"
          });
          return;
        }
        content = tinymce.activeEditor.MediaWiki.embedMetadata(tinymce.activeEditor.getContent(), tinymce.activeEditor.Settings.document.metadata);
        return tinymce.activeEditor.MediaWiki.exportPage(pageName, content, postCallback);
      };
      return tinymce.activeEditor.MediaWiki.login(username, password, loginCallback);
    }
  };

  window.afterEditorReadyArray.push(function(editor) {
    var autoLoadName, document, html, match, metadata, toAutoLoad, _ref, _ref1;
    editor.MediaWiki.setIndexPage('/wiki/index.php');
    editor.MediaWiki.setAPIPage('/wiki/api.php');
    if (match = /\?wikipage=(.*)/.exec(window.location.search)) {
      editor.MediaWiki.importPage(decodeURIComponent(match[1], function(document, metadata) {
        if (metadata != null) {
          return editor.LoadSave.loadMetaData(metadata);
        }
      }));
    }
    autoLoadName = 'auto-load';
    if (match = /\?autoload=(.*)/.exec(window.location.search)) {
      autoLoadName = decodeURIComponent(match[1]);
    }
    if (toAutoLoad = localStorage.getItem(autoLoadName)) {
      try {
        _ref = JSON.parse(toAutoLoad), metadata = _ref[0], document = _ref[1];
        setTimeout(function() {
          var m, shorthandRE;
          localStorage.removeItem(autoLoadName);
          shorthandRE = /^\s*<shorthand>(.*)<\/shorthand>\s*$/;
          document = document.replace(/\n|\cJ/g, ' ');
          if (m = shorthandRE.exec(document)) {
            translateShorthandIntoEditor(document);
          } else {
            tinymce.activeEditor.setContent(document);
          }
          return editor.LoadSave.loadMetaData(metadata);
        }, 100);
      } catch (_error) {}
    }
    if (match = /\?document=(.*)/.exec(window.location.search)) {
      html = decodeURIComponent(match[1]);
      _ref1 = extractMetadata(html), metadata = _ref1.metadata, document = _ref1.document;
      localStorage.setItem('auto-load', JSON.stringify([metadata, document]));
      return window.location.href = window.location.href.split('?')[0];
    }
  });

  appIsRunningOnGitHub = function() {
    var result;
    result = /nathancarter\.github\.io/.test(window.location.href);
    if (result) {
      tinymce.activeEditor.Dialogs.alert({
        title: 'Not Available Here',
        message: '<p>That functionality requires MediaWiki to be running on the server from which you\'re accessing this web app.</p> <p>On GitHub, we cannot run a MediaWiki server, so the functionality is disabled.</p> <p>The menu items remain for use in developer testing, as we prepare for a dedicated server that will have MediaWiki and the ability to publish documents to that wiki with a single click, or edit them in Lurch with a single click.</p> <p>Try back soon!</p>'
      });
    }
    return result;
  };

  translateShorthandIntoEditor = function(shorthand) {
    var already, connections, div, doc, group, id, idToKey, idToN, internalKey, internalValue, n, nToId, nextId, recur, source, sourceId, target, targetNs, _i, _j, _len, _ref;
    doc = tinymce.activeEditor.getDoc();
    div = doc.createElement('div');
    div.innerHTML = shorthand;
    nToId = {};
    idToN = {};
    connections = {};
    idToKey = {};
    nextId = 0;
    recur = function(element) {
      var child, copy, i, n, thisId, translatedChildren, _ref;
      if (element.tagName === 'E') {
        thisId = nextId++;
      }
      translatedChildren = (function() {
        var _i, _len, _ref, _results;
        _ref = element.childNodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          _results.push(recur(child));
        }
        return _results;
      })();
      if (element.tagName === 'E') {
        if (element.hasAttribute('n')) {
          n = element.getAttribute('n');
          nToId[n] = thisId;
          idToN[thisId] = n;
        }
        if (element.hasAttribute('at')) {
          idToKey[thisId] = element.getAttribute('at');
        }
        if (element.hasAttribute('to')) {
          connections[thisId] = (function() {
            var _i, _len, _ref, _results;
            _ref = element.getAttribute('to').split(',');
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              i = _ref[_i];
              _results.push(Number(i));
            }
            return _results;
          })();
        }
        return grouperHTML('expression', 'open', thisId, false, '') + translatedChildren.join('') + grouperHTML('expression', 'close', thisId, false, '');
      } else {
        copy = element.cloneNode(false);
        copy.innerHTML = translatedChildren.join('');
        return (_ref = copy.outerHTML) != null ? _ref : copy.textContent;
      }
    };
    tinymce.activeEditor.setContent(recur(div));
    tinymce.activeEditor.Groups.scanDocument();
    for (id = _i = nextId; nextId <= 0 ? _i <= 0 : _i >= 0; id = nextId <= 0 ? ++_i : --_i) {
      if (id in idToKey) {
        if (!(group = tinymce.activeEditor.Groups[id])) {
          continue;
        }
        internalKey = OM.encodeAsIdentifier(idToKey[id]);
        internalValue = {
          m: group.completeForm().encode(),
          v: LZString.compress(group.groupAsHTML(false))
        };
        if (already = group.parent.get(internalKey)) {
          if ((_ref = already.m.children[0]) != null ? _ref.equals(OM.sym('List', 'Lurch')) : void 0) {
            already.m = OM.app.apply(OM, [already.m.children[0], OM.decode(internalValue.m)].concat(__slice.call(already.m.children[1])));
          } else {
            already.m = OM.app(OM.sym('List', 'Lurch'), already.m, OM.decode(internalValue.m));
          }
          already.v = internalValue.v + already.v;
          internalValue = already;
        }
        group.parent.set(internalKey, internalValue);
        group.remove();
      }
    }
    for (sourceId in connections) {
      targetNs = connections[sourceId];
      if (!(source = tinymce.activeEditor.Groups[sourceId])) {
        continue;
      }
      for (_j = 0, _len = targetNs.length; _j < _len; _j++) {
        n = targetNs[_j];
        if (target = tinymce.activeEditor.Groups[nToId[n]]) {
          source.connect(target);
        }
      }
    }
    return tinymce.activeEditor.undoManager.clear();
  };

}).call(this);

//# sourceMappingURL=main-app-import-export-solo.js.map
