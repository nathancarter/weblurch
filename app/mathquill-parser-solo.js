// Generated by CoffeeScript 1.8.0
(function() {
  var G, Grammar, OM, OMNode, exports, _ref, _ref1,
    __slice = [].slice;

  if (typeof exports === "undefined" || exports === null) {
    exports = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : window;
  }

  if (typeof require !== "undefined" && require !== null) {
    _ref1 = require('./openmath.duo'), OM = _ref1.OM, OMNode = _ref1.OMNode;
    Grammar = require('./parsing.duo').Grammar;
  } else {
    Grammar = window.Grammar;
    OM = window.OM;
    OMNode = window.OMNode;
  }

  window.mathQuillToMeaning = exports.mathQuillToMeaning = function(node) {
    var child, marker, name, result, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3, _ref4, _ref5;
    if (node instanceof Text) {
      return node.textContent;
    }
    result = [];
    _ref2 = node.childNodes;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      child = _ref2[_i];
      if (($(child)).hasClass('selectable') || ($(child)).hasClass('cursor') || /width:0/.test(typeof child.getAttribute === "function" ? child.getAttribute('style') : void 0)) {
        continue;
      }
      result = result.concat(mathQuillToMeaning(child));
    }
    if ((_ref3 = node.tagName) === 'SUP' || _ref3 === 'SUB') {
      name = node.tagName.toLowerCase();
      if (($(node)).hasClass('nthroot')) {
        name = 'nthroot';
      }
      if (result.length > 1) {
        result.unshift('(');
        result.push(')');
      }
      result.unshift(name);
    }
    _ref4 = ['fraction', 'overline', 'overarc'];
    for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
      marker = _ref4[_j];
      if (($(node)).hasClass(marker)) {
        if (result.length > 1) {
          result.unshift('(');
          result.push(')');
        }
        result.unshift(marker);
      }
    }
    _ref5 = ['numerator', 'denominator'];
    for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
      marker = _ref5[_k];
      if (($(node)).hasClass(marker)) {
        if (result.length > 1) {
          result.unshift('(');
          result.push(')');
        }
      }
    }
    if (result.length === 1) {
      return result[0];
    } else {
      return result;
    }
  };

  exports.mathQuillParser = G = new Grammar('expression');

  G.addRule('digit', /[0-9]/);

  G.addRule('nonnegint', 'digit');

  G.addRule('nonnegint', ['digit', 'nonnegint']);

  G.addRule('integer', 'nonnegint');

  G.addRule('integer', [/-/, 'nonnegint']);

  G.addRule('float', ['integer', /\./, 'nonnegint']);

  G.addRule('float', ['integer', /\./]);

  G.addRule('infinity', [/∞/]);

  G.addRule('variable', /[a-zA-Z\u0374-\u03FF]/);

  G.addRule('atomic', 'integer');

  G.addRule('atomic', 'float');

  G.addRule('atomic', 'variable');

  G.addRule('atomic', 'infinity');

  G.addRule('factor', 'atomic');

  G.addRule('factor', ['atomic', /sup/, 'atomic']);

  G.addRule('factor', ['factor', /[%]/]);

  G.addRule('factor', [/\$/, 'factor']);

  G.addRule('factor', ['factor', /sup/, /[∘]/]);

  G.addRule('prodquo', 'factor');

  G.addRule('prodquo', ['prodquo', /[÷×·]/, 'factor']);

  G.addRule('prodquo', [/-/, 'prodquo']);

  G.addRule('sumdiff', 'prodquo');

  G.addRule('sumdiff', ['sumdiff', /[+±−-]/, 'prodquo']);

  G.addRule('ln', [/ln/, 'atomic']);

  G.addRule('log', [/log/, 'atomic']);

  G.addRule('log', [/log/, /sub/, 'atomic', 'atomic']);

  G.addRule('prodquo', 'ln');

  G.addRule('prodquo', 'log');

  G.addRule('factorial', ['atomic', /!/]);

  G.addRule('factor', 'factorial');

  G.addRule('setdiff', 'variable');

  G.addRule('setdiff', ['setdiff', /[∼]/, 'variable']);

  G.addRule('subscripted', ['atomic', /sub/, 'atomic']);

  G.addRule('noun', 'subscripted');

  G.addRule('fraction', [/fraction/, /\(/, 'atomic', 'atomic', /\)/]);

  G.addRule('atomic', 'fraction');

  G.addRule('root', [/√/, 'atomic']);

  G.addRule('root', [/nthroot/, 'atomic', /√/, 'atomic']);

  G.addRule('atomic', 'root');

  G.addRule('decoration', [/overline/, 'atomic']);

  G.addRule('decoration', [/overarc/, 'atomic']);

  G.addRule('atomic', 'decoration');

  G.addRule('trigfunc', [/sin|cos|tan|cot|sec|csc/]);

  G.addRule('trigapp', ['trigfunc', 'prodquo']);

  G.addRule('trigapp', ['trigfunc', /sup/, /\(/, /-|−/, /1/, /\)/, 'prodquo']);

  G.addRule('atomic', 'trigapp');

  G.addRule('limit', [/lim/, /sub/, /\(/, 'variable', /[→]/, 'expression', /\)/, 'prodquo']);

  G.addRule('takesleftcoeff', 'limit');

  G.addRule('sum', [/[Σ]/, /sub/, /\(/, 'variable', /[=]/, 'expression', /\)/, /sup/, 'atomic', 'prodquo']);

  G.addRule('sum', [/[Σ]/, /sup/, 'atomic', /sub/, /\(/, 'variable', /[=]/, 'expression', /\)/, 'prodquo']);

  G.addRule('takesleftcoeff', 'sum');

  G.addRule('differential', [/d/, 'atomic']);

  G.addRule('difffrac', [/fraction/, /\(/, /d/, /\(/, /d/, 'variable', /\)/, /\)/]);

  G.addRule('indefint', [/[∫]/, 'prodquo']);

  G.addRule('defint', [/[∫]/, /sub/, 'atomic', /sup/, 'atomic', 'prodquo']);

  G.addRule('defint', [/[∫]/, /sup/, 'atomic', /sub/, 'atomic', 'prodquo']);

  G.addRule('factor', 'differential');

  G.addRule('factor', 'difffrac');

  G.addRule('takesleftcoeff', 'indefint');

  G.addRule('takesleftcoeff', 'defint');

  G.addRule('sumdiff', 'takesleftcoeff');

  G.addRule('sumdiff', ['factor', /[÷×·]/, 'takesleftcoeff']);

  G.addRule('sumdiff', ['prodquo', /[+±−-]/, 'takesleftcoeff']);

  G.addRule('noun', 'sumdiff');

  G.addRule('noun', 'setdiff');

  G.addRule('atomicsentence', ['noun', /[=≠≈≃≤≥<>]/, 'noun']);

  G.addRule('atomicsentence', [/[¬]/, 'atomicsentence']);

  G.addRule('sentence', 'atomicsentence');

  G.addRule('sentence', [/[∴]/, 'sentence']);

  G.addRule('atomic', [/\(/, 'noun', /\)/]);

  G.addRule('atomicsentence', [/\(/, 'sentence', /\)/]);

  G.addRule('interval', [/[\(\[]/, 'noun', /,/, 'noun', /[\)\]]/]);

  G.addRule('atomic', 'interval');

  G.addRule('absval', [/\|/, 'noun', /\|/]);

  G.addRule('atomic', 'absval');

  G.addRule('expression', 'noun');

  G.addRule('expression', 'sentence');

  G.setOption('expressionBuilder', function(expr) {
    var a, b, build, from, left, result, right, symbols, to, varname;
    symbols = {
      '+': OM.symbol('plus', 'arith1'),
      '-': OM.symbol('minus', 'arith1'),
      '−': OM.symbol('minus', 'arith1'),
      '±': OM.symbol('plusminus', 'multiops'),
      '×': OM.symbol('times', 'arith1'),
      '·': OM.symbol('times', 'arith1'),
      '÷': OM.symbol('divide', 'arith1'),
      '^': OM.symbol('power', 'arith1'),
      '∞': OM.symbol('infinity', 'nums1'),
      '√': OM.symbol('root', 'arith1'),
      '∼': OM.symbol('set1', 'setdiff'),
      '=': OM.symbol('eq', 'relation1'),
      '<': OM.symbol('lt', 'relation1'),
      '>': OM.symbol('gt', 'relation1'),
      '≠': OM.symbol('neq', 'relation1'),
      '≈': OM.symbol('approx', 'relation1'),
      '≤': OM.symbol('le', 'relation1'),
      '≥': OM.symbol('ge', 'relation1'),
      '≃': OM.symbol('modulo_relation', 'integer2'),
      '¬': OM.symbol('not', 'logic1'),
      '∘': OM.symbol('degrees', 'units'),
      '$': OM.symbol('dollars', 'units'),
      '%': OM.symbol('percent', 'units'),
      '∫': OM.symbol('int', 'calculus1'),
      'def∫': OM.symbol('defint', 'calculus1'),
      'ln': OM.symbol('ln', 'transc1'),
      'log': OM.symbol('log', 'transc1'),
      'unary-': OM.symbol('unary_minus', 'arith1'),
      'overarc': OM.symbol('overarc', 'decoration'),
      'overline': OM.symbol('overline', 'decoration'),
      'd': OM.symbol('d', 'diff')
    };
    build = function() {
      var a, arg, args, argstrs, tmp;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      args = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          a = args[_i];
          if (typeof a === 'number') {
            a = expr[a];
          }
          if (symbols.hasOwnProperty(a)) {
            a = symbols[a];
          }
          if (typeof a === 'string') {
            a = OM.decode(a);
          }
          _results.push(a);
        }
        return _results;
      })();
      tmp = OM.application.apply(OM, args);
      if (G.expressionBuilderDebug) {
        argstrs = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            arg = args[_i];
            if (arg instanceof OMNode) {
              _results.push(arg.encode());
            } else {
              _results.push("" + arg);
            }
          }
          return _results;
        })();
        console.log.apply(console, ['build'].concat(__slice.call(argstrs), ['-->'], [tmp]));
      }
      return tmp;
    };
    result = (function() {
      var _ref2, _ref3;
      switch (expr[0]) {
        case 'digit':
        case 'nonnegint':
          return expr.slice(1).join('');
        case 'integer':
          return OM.integer(parseInt(expr.slice(1).join('')));
        case 'float':
          return OM.float(parseFloat("" + expr[1].value + (expr.slice(2).join(''))));
        case 'variable':
          return OM.variable(expr[1]);
        case 'infinity':
          return symbols[expr[1]];
        case 'sumdiff':
        case 'prodquo':
          switch (expr.length) {
            case 4:
              return build(2, 1, 3);
            case 3:
              return build('unary-', 2);
          }
          break;
        case 'factor':
          switch (expr.length) {
            case 4:
              if (expr[3] === '∘') {
                return build('×', 1, symbols['∘']);
              } else {
                return build('^', 1, 3);
              }
              break;
            case 3:
              if (expr[2] === '%') {
                return build('×', 1, symbols['%']);
              } else {
                return build('×', 2, symbols['$']);
              }
          }
          break;
        case 'fraction':
          return build('÷', 3, 4);
        case 'root':
          switch (expr.length) {
            case 3:
              return build('√', 2, OM.integer(2));
            case 5:
              return build('√', 4, 2);
          }
          break;
        case 'ln':
          return build('ln', 2);
        case 'log':
          switch (expr.length) {
            case 3:
              return build('log', OM.integer(10), 2);
            case 5:
              return build('log', 3, 4);
          }
          break;
        case 'atomic':
          if (expr.length === 4 && expr[1] === '(' && expr[3] === ')') {
            return expr[2];
          }
          break;
        case 'atomicsentence':
          switch (expr.length) {
            case 4:
              return build(2, 1, 3);
            case 3:
              return build(1, 2);
          }
          break;
        case 'decoration':
          return build(1, 2);
        case 'sentence':
          if (expr[1] === '∴') {
            return expr[2];
          }
          break;
        case 'interval':
          left = expr[1] === '(' ? 'o' : 'c';
          right = expr[5] === ')' ? 'o' : 'c';
          return build(OM.symbol("interval_" + left + right, 'interval1'), 2, 4);
        case 'absval':
          return build(OM.symbol('abs', 'arith1'), 2);
        case 'trigapp':
          switch (expr.length) {
            case 3:
              return build(OM.symbol(expr[1], 'transc1'), 2);
            case 8:
              return build(OM.symbol("arc" + expr[1], 'transc1'), 7);
          }
          break;
        case 'subscripted':
          return build(1, 3);
        case 'factorial':
          return build(OM.symbol('factorial', 'integer1'), 1);
        case 'limit':
          return build(OM.symbol('limit', 'limit1'), 6, OM.symbol('both_sides', 'limit1'), OM.binding(OM.symbol('lambda', 'fns1'), expr[4], expr[8]));
        case 'sum':
          _ref2 = expr[2] === 'sup' ? [6, 8, 3] : [4, 6, 9], varname = _ref2[0], from = _ref2[1], to = _ref2[2];
          return build(OM.symbol('sum', 'arith1'), OM.application(OM.symbol('interval', 'interval1'), expr[from], expr[to]), OM.binding(OM.symbol('lambda', 'fns1'), expr[varname], expr[10]));
        case 'differential':
          return build('d', 2);
        case 'difffrac':
          return build('÷', 'd', build('d', 6));
        case 'indefint':
          return build('∫', 2);
        case 'defint':
          _ref3 = expr[2] === 'sup' ? [5, 3] : [3, 5], a = _ref3[0], b = _ref3[1];
          return build('def∫', a, b, 6);
      }
    })();
    if (result == null) {
      result = expr[1];
    }
    if (G.expressionBuilderDebug) {
      console.log((expr instanceof OMNode ? expr.encode() : "" + expr), '--->', result instanceof OMNode ? result.encode() : result);
    }
    return result;
  });

  G.setOption('comparator', function(a, b) {
    return a != null ? typeof a.equals === "function" ? a.equals(b) : void 0 : void 0;
  });

}).call(this);

//# sourceMappingURL=mathquill-parser-solo.js.map
