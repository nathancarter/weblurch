// Generated by CoffeeScript 1.8.0
(function() {
  var __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.Group.prototype.canonicalForm = function() {
    var child;
    if (this.children.length === 0) {
      return OM.str(this.contentAsText());
    } else {
      return OM.app.apply(OM, (function() {
        var _i, _len, _ref, _results;
        _ref = this.children;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          _results.push(child.canonicalForm());
        }
        return _results;
      }).call(this));
    }
  };

  window.Group.prototype.attributeGroups = function(includePremises) {
    var connection, key, result, source, _i, _len, _ref;
    if (includePremises == null) {
      includePremises = false;
    }
    result = [];
    _ref = this.connectionsIn();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connection = _ref[_i];
      source = tinymce.activeEditor.Groups[connection[0]];
      if (key = source.get('key')) {
        if (!includePremises && key === 'premise') {
          continue;
        }
        result.push(source);
      }
    }
    return result;
  };

  window.Group.prototype.attributionAncestry = function(includePremises) {
    var group, otherGroup, result, _i, _j, _len, _len1, _ref, _ref1;
    if (includePremises == null) {
      includePremises = false;
    }
    result = [];
    _ref = this.attributeGroups(includePremises);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      _ref1 = [group].concat(__slice.call(group.attributionAncestry()));
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        otherGroup = _ref1[_j];
        if (__indexOf.call(result, otherGroup) < 0) {
          result.push(otherGroup);
        }
      }
    }
    return result;
  };

  window.Group.prototype.completeForm = function(includePremises) {
    var group, key, list, prepare, result, _i, _len, _ref;
    if (includePremises == null) {
      includePremises = false;
    }
    result = this.canonicalForm();
    prepare = {};
    _ref = this.attributeGroups(includePremises);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      key = group.get('key');
      (prepare[key] != null ? prepare[key] : prepare[key] = []).push(group);
    }
    for (key in prepare) {
      list = prepare[key];
      list = (function() {
        var _j, _len1, _ref1, _results;
        _ref1 = list.sort(strictNodeComparator);
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          group = _ref1[_j];
          _results.push(group.completeForm(includePremises));
        }
        return _results;
      })();
      result = OM.att(result, OM.sym(key, 'Lurch'), list.length === 1 ? list[0] : OM.app.apply(OM, [OM.sym('List', 'Lurch')].concat(__slice.call(list))));
    }
    return result;
  };

  window.Group.prototype.embedAttribute = function(key) {
    var ancestry, g, groups, internalKey, internalValue;
    groups = (function() {
      var _i, _len, _ref, _results;
      _ref = this.attributeGroups();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        g = _ref[_i];
        if (g.get('key') === key) {
          _results.push(g);
        }
      }
      return _results;
    }).call(this);
    if (groups.length !== 1) {
      return;
    }
    internalKey = OM.encodeAsIdentifier(key);
    internalValue = {
      m: g.completeForm()
    };
    groups[0].disconnect(this);
    ancestry = groups[0].attributionAncestry();
    ancestry.sort(strictNodeComparator);
    internalValue.v = LZString.compress(((function() {
      var _i, _len, _ref, _results;
      _ref = [groups[0]].concat(__slice.call(ancestry));
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        g = _ref[_i];
        _results.push(g.groupAsHTML(false));
      }
      return _results;
    })()).join(''));
    return groups[0].plugin.editor.undoManager.transact((function(_this) {
      return function() {
        var a, ancestor, ancestorIds, connection, hasConnectionToNonAncestor, _i, _j, _len, _len1, _ref, _ref1, _results;
        _this.set(internalKey, internalValue);
        groups[0].remove();
        ancestorIds = [groups[0].id()].concat(__slice.call((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = ancestry.length; _i < _len; _i++) {
              a = ancestry[_i];
              _results.push(a.id());
            }
            return _results;
          })()));
        _results = [];
        for (_i = 0, _len = ancestry.length; _i < _len; _i++) {
          ancestor = ancestry[_i];
          hasConnectionToNonAncestor = false;
          _ref = ancestor.connectionsOut();
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            connection = _ref[_j];
            if (_ref1 = connection[1], __indexOf.call(ancestorIds, _ref1) < 0) {
              hasConnectionToNonAncestor = true;
              break;
            }
          }
          if (!hasConnectionToNonAncestor) {
            _results.push(ancestor.remove());
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
    })(this));
  };

}).call(this);

//# sourceMappingURL=main-app-group-class-solo.js.map
