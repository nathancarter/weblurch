// Generated by CoffeeScript 1.8.0
(function() {
  var addExpression, addLabelPair, clearLabelPairs, deleteExpression, groupOrder, labelPairs, logLabelPairs, pairOrder,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  labelPairs = [];

  groupOrder = function(group1, key1, index1, group2, key2, index2) {
    var maybeResult;
    if (group1 instanceof OM) {
      if (group2 instanceof OM) {
        return group1.encode().localeCompare(group2.encode());
      } else {
        return -1;
      }
    }
    if (group2 instanceof OM) {
      return 1;
    }
    if ((key1 == null) || (index1 == null)) {
      if (group1.open === group2.open) {
        if ((key2 == null) || (index2 == null)) {
          return 0;
        } else {
          return 1;
        }
      } else {
        return strictNodeComparator(group1.open, group2.open);
      }
    }
    maybeResult = strictNodeComparator(group1.open, group2.open);
    if (maybeResult !== 0) {
      return maybeResult;
    }
    maybeResult = key1.localeCompare(key2);
    if (maybeResult !== 0) {
      return maybeResult;
    }
    return index1 - index2;
  };

  pairOrder = function(pairA, pairB) {
    var firstA, firstB, group, index, key, result, secondA, secondB, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    _ref = [pairA.source], group = _ref[0], key = _ref[1], index = _ref[2];
    if (typeof group === 'number') {
      index = group;
      group = pairA.target;
      key = 'label';
    }
    if (groupOrder(group, key, index, pairA.target) === -1) {
      _ref1 = [group, pairA.target], firstA = _ref1[0], secondA = _ref1[1];
    } else {
      _ref2 = [pairA.target, group], firstA = _ref2[0], secondA = _ref2[1];
    }
    _ref3 = [pairB.source], group = _ref3[0], key = _ref3[1], index = _ref3[2];
    if (typeof group === 'number') {
      index = group;
      group = pairB.target;
      key = 'label';
    }
    if (groupOrder(group, key, index, pairA.target) === -1) {
      _ref4 = [group, pairB.target], firstB = _ref4[0], secondB = _ref4[1];
    } else {
      _ref5 = [pairB.target, group], firstB = _ref5[0], secondB = _ref5[1];
    }
    result = groupOrder(secondA, void 0, void 0, secondB) || groupOrder(firstA, void 0, void 0, firstB);
    return result;
  };

  clearLabelPairs = function() {
    return labelPairs = [];
  };

  window.afterEditorReadyArray.push(function(editor) {
    var oldLoadMetaDataHandler;
    oldLoadMetaDataHandler = editor.LoadSave.loadMetaData;
    return editor.LoadSave.loadMetaData = function(object) {
      var group, grouper, _i, _len, _ref;
      clearLabelPairs();
      _ref = editor.Groups.allGroupers();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        grouper = _ref[_i];
        group = editor.Groups.grouperToGroup(grouper);
        if (group.open === grouper && group.typeName() === 'expression') {
          addExpression(group);
        }
      }
      return oldLoadMetaDataHandler(object);
    };
  });

  addLabelPair = function(pair) {
    var bottom, middle, top, whichWay;
    if (labelPairs.length === 0) {
      return labelPairs.push(pair);
    }
    bottom = 0;
    top = labelPairs.length;
    while (bottom !== top) {
      middle = Math.floor((bottom + top) / 2);
      whichWay = pairOrder(pair, labelPairs[middle]);
      if (whichWay === 0) {
        return;
      }
      if (whichWay === -1) {
        top = middle;
      } else {
        bottom = middle + 1;
      }
    }
    if (bottom === labelPairs.length) {
      return labelPairs.push(pair);
    } else {
      return labelPairs.splice(bottom, 0, pair);
    }
  };

  addExpression = function(expression) {
    var addInternalLabels, external, internals, labelKey, _i, _len, _ref;
    labelKey = OM.encodeAsIdentifier('label');
    addInternalLabels = function(labelOrLabelList) {
      var index, label, labels, value, _i, _len, _results;
      labels = labelOrLabelList.type === 'a' && labelOrLabelList.children[0].equals(Group.prototype.listSymbol) ? labelOrLabelList.children.slice(1) : [labelOrLabelList];
      _results = [];
      for (index = _i = 0, _len = labels.length; _i < _len; index = ++_i) {
        label = labels[index];
        if (value = label.value) {
          _results.push(addLabelPair({
            target: expression,
            source: index,
            label: value
          }));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    if (expression instanceof Group) {
      _ref = expression.attributeGroupsForKey('label');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        external = _ref[_i];
        if (external.children.length === 0) {
          addLabelPair({
            target: expression,
            source: external,
            label: external.contentAsText()
          });
        }
      }
      if (!(internals = expression.get(labelKey))) {
        return;
      }
      if (internals = OM.decode(internals.m)) {
        return addInternalLabels(internals);
      }
    } else if (expression instanceof OM) {
      internals = expression.getAttribute(OM.sym('label', 'Lurch'));
      if (internals) {
        return addInternalLabels(internals);
      }
    }
  };

  deleteExpression = function(expression) {
    var pair;
    return labelPairs = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = labelPairs.length; _i < _len; _i++) {
        pair = labelPairs[_i];
        if (pair.source !== expression && pair.target !== expression && (!(pair.target instanceof Group) || pair.target.stillInEditor())) {
          _results.push(pair);
        }
      }
      return _results;
    })();
  };

  window.afterEditorReadyArray.push(function(editor) {
    var refreshExpression, refreshHandler;
    editor.Groups.groupTypes.expression.deleted = function(group) {
      var connection, target, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      _ref = group.connectionsOut();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        connection = _ref[_i];
        target = editor.Groups[connection[1]];
        if (target != null) {
          group.disconnect(target);
        }
      }
      _ref1 = group.connectionsIn();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        connection = _ref1[_j];
        if ((_ref2 = editor.Groups[connection[0]]) != null) {
          _ref2.disconnect(group);
        }
      }
      return deleteExpression(group);
    };
    refreshExpression = function(expression) {
      deleteExpression(expression);
      return addExpression(expression);
    };
    refreshHandler = function(group, firstTime) {
      var connection, _i, _len, _ref, _results;
      if (firstTime == null) {
        firstTime = false;
      }
      if (firstTime) {
        return setTimeout(refreshHandler, 0, group);
      }
      refreshExpression(group);
      if (group.get('key') === 'label' && (editor = group.plugin.editor)) {
        _ref = group.connectionsOut();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          connection = _ref[_i];
          _results.push(refreshExpression(editor.Groups[connection[1]]));
        }
        return _results;
      }
    };
    editor.Groups.groupTypes.expression.contentsChanged = refreshHandler;
    return editor.on('dependenciesChanged', function() {
      var dependency, newLabelPairs, newLabels, originalLabels, pair, recur, _i, _j, _len, _len1, _ref;
      originalLabels = [];
      newLabelPairs = [];
      for (_i = 0, _len = labelPairs.length; _i < _len; _i++) {
        pair = labelPairs[_i];
        if (pair.target instanceof window.Group) {
          newLabelPairs.push(pair.target);
        } else {
          originalLabels.push(pair.label);
        }
      }
      labelPairs = newLabelPairs;
      recur = function(dependency) {
        var expression, innerDep, _j, _k, _len1, _len2, _ref, _ref1, _ref2, _results;
        _ref = dependency.data;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          expression = _ref[_j];
          addExpression(OM.decode(expression));
        }
        _ref2 = (_ref1 = dependency.dependencies) != null ? _ref1 : [];
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          innerDep = _ref2[_k];
          _results.push(recur(innerDep));
        }
        return _results;
      };
      _ref = editor.Dependencies;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        dependency = _ref[_j];
        recur(dependency);
      }
      newLabels = (function() {
        var _k, _len2, _ref1, _results;
        _results = [];
        for (_k = 0, _len2 = labelPairs.length; _k < _len2; _k++) {
          pair = labelPairs[_k];
          if (!(pair.target instanceof Group) && (_ref1 = pair.label, __indexOf.call(originalLabels, _ref1) < 0)) {
            _results.push(pair.label);
          }
        }
        return _results;
      })();
      return editor.fire('dependencyLabelsUpdated', {
        oldAndNewLabels: __slice.call(originalLabels).concat(__slice.call(newLabels))
      });
    });
  });

  window.lookupLabel = function(labelText, fromThisElement) {
    var accessible, pair, _i, _len, _results;
    if (fromThisElement == null) {
      fromThisElement = null;
    }
    accessible = function(pair) {
      var one, two;
      if (fromThisElement == null) {
        return true;
      }
      if (pair.target instanceof OM) {
        return true;
      }
      one = pair.target.open;
      two = pair.source instanceof Group ? pair.source.open : pair.target.open;
      return strictNodeOrder(one, fromThisElement) && strictNodeOrder(two, fromThisElement);
    };
    _results = [];
    for (_i = 0, _len = labelPairs.length; _i < _len; _i++) {
      pair = labelPairs[_i];
      if (pair.label === labelText && accessible(pair)) {
        _results.push(pair);
      }
    }
    return _results;
  };

  window.lookupLabelsFor = function(expression) {
    var pair, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = labelPairs.length; _i < _len; _i++) {
      pair = labelPairs[_i];
      if (pair.target === expression) {
        _results.push(pair.label);
      }
    }
    return _results;
  };

  window.labeledTopLevelExpressions = function() {
    var pair, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = labelPairs.length; _i < _len; _i++) {
      pair = labelPairs[_i];
      if (pair.target instanceof Group && (pair.target.parent == null)) {
        _results.push(pair.target);
      }
    }
    return _results;
  };

  logLabelPairs = function() {
    var logGroup, pair, _i, _len;
    logGroup = function(group) {
      if (group instanceof Group) {
        return "" + (group.id()) + ":" + (group.contentAsText());
      }
      if (group instanceof OM) {
        return group.simpleEncode();
      }
      return group;
    };
    console.log('----------- LABEL PAIRS ---------------');
    for (_i = 0, _len = labelPairs.length; _i < _len; _i++) {
      pair = labelPairs[_i];
      console.log("" + (logGroup(pair.target)) + " <--\"" + pair.label + "\"-- " + (logGroup(pair.source)));
    }
    return console.log('---------------------------------------');
  };

}).call(this);

//# sourceMappingURL=main-app-group-labels-solo.js.map
