// Generated by CoffeeScript 1.8.0
(function() {
  var CLSetToString, CLToString, CToString, Constraint, ConstraintList, OM, OMNode, alphaEquivalent, applyExpressionFunction, bindingConstraints1, bindingConstraints2, clearMetavariable, composeIterator, concatenateIterators, consistentPatterns, differenceIterator, exports, expressionDepth, expressionFunction, expressionFunctionApplication, filterIterator, findDifferencesBetween, isExpressionFunction, isExpressionFunctionApplication, isMetavariable, makeExpressionFunction, makeExpressionFunctionApplication, matchDebug, matchDebugOn, metavariableSymbol, multiReplace, nextMatch, parentAddresses, partitionedAddresses, prefixIterator, sameDepthAncestors, satisfiesBindingConstraints1, satisfiesBindingConstraints2, setMetavariable, subexpressionIterator, suffixIterator, trueValue, _ref, _ref1,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof exports === "undefined" || exports === null) {
    exports = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : window;
  }

  if (typeof require !== "undefined" && require !== null) {
    _ref1 = require('./openmath-duo'), OM = _ref1.OM, OMNode = _ref1.OMNode;
  }

  metavariableSymbol = OM.symbol('metavariable', 'lurch');

  trueValue = OM.string('true');

  exports.setMetavariable = setMetavariable = function(variable) {
    var _ref2;
    if (!(variable instanceof OMNode) || ((_ref2 = variable.type) !== 'v' && _ref2 !== 'sy')) {
      return;
    }
    return variable.setAttribute(metavariableSymbol, trueValue.copy());
  };

  exports.clearMetavariable = clearMetavariable = function(metavariable) {
    return metavariable.removeAttribute(metavariableSymbol);
  };

  exports.isMetavariable = isMetavariable = function(variable) {
    var _ref2, _ref3;
    return variable instanceof OMNode && ((_ref2 = variable.type) === 'v' || _ref2 === 'sy') && ((_ref3 = variable.getAttribute(metavariableSymbol)) != null ? _ref3.equals(trueValue) : void 0);
  };

  expressionFunction = OM.symbol('EF', 'lurch');

  expressionFunctionApplication = OM.symbol('EFA', 'lurch');

  exports.makeExpressionFunction = makeExpressionFunction = (function(_this) {
    return function(variable, body) {
      if (variable.type !== 'v') {
        throw 'When creating an expression function, its parameter must be a variable';
      }
      return OM.bin(expressionFunction, variable, body);
    };
  })(this);

  exports.isExpressionFunction = isExpressionFunction = (function(_this) {
    return function(expression) {
      return expression.type === 'bi' && expression.variables.length === 1 && expression.symbol.equals(expressionFunction);
    };
  })(this);

  exports.makeExpressionFunctionApplication = makeExpressionFunctionApplication = (function(_this) {
    return function(func, argument) {
      return OM.app(expressionFunctionApplication, func, argument);
    };
  })(this);

  exports.isExpressionFunctionApplication = isExpressionFunctionApplication = (function(_this) {
    return function(expression) {
      return expression.type === 'a' && expression.children.length === 3 && expression.children[0].equals(expressionFunctionApplication);
    };
  })(this);

  exports.applyExpressionFunction = applyExpressionFunction = function(func, expression) {
    var result;
    result = func.body.copy();
    result.replaceFree(func.variables[0], expression);
    return result;
  };

  exports.alphaEquivalent = alphaEquivalent = function(func1, func2) {
    var apply1, apply2, index, isNewVar, newVar, pair;
    index = 0;
    newVar = function() {
      return OM["var"]("v" + index);
    };
    isNewVar = function(expr) {
      return expr.equals(newVar());
    };
    pair = OM.app(func1, func2);
    while (pair.hasDescendantSatisfying(isNewVar)) {
      index++;
    }
    apply1 = applyExpressionFunction(func1, newVar());
    apply2 = applyExpressionFunction(func2, newVar());
    return isExpressionFunction(func1) && isExpressionFunction(func2) && apply1.equals(apply2);
  };

  exports.consistentPatterns = consistentPatterns = function() {
    var M, functionMetavariables, nonFunctionMetavariables, pattern, patterns, _i, _j, _len, _len1, _ref2, _ref3, _ref4, _ref5, _ref6;
    patterns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    nonFunctionMetavariables = [];
    functionMetavariables = [];
    for (_i = 0, _len = patterns.length; _i < _len; _i++) {
      pattern = patterns[_i];
      _ref2 = pattern.descendantsSatisfying(isMetavariable);
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        M = _ref2[_j];
        if (isExpressionFunctionApplication(M.parent) && M.findInParent() === 'c1') {
          if (_ref3 = M.name, __indexOf.call(nonFunctionMetavariables, _ref3) >= 0) {
            return false;
          }
          if (_ref4 = M.name, __indexOf.call(functionMetavariables, _ref4) < 0) {
            functionMetavariables.push(M.name);
          }
        } else {
          if (_ref5 = M.name, __indexOf.call(functionMetavariables, _ref5) >= 0) {
            return false;
          }
          if (_ref6 = M.name, __indexOf.call(nonFunctionMetavariables, _ref6) < 0) {
            nonFunctionMetavariables.push(M.name);
          }
        }
      }
    }
    return true;
  };

  exports.Constraint = Constraint = (function() {
    function _Class(pattern, expression) {
      this.pattern = pattern;
      this.expression = expression;
    }

    _Class.prototype.copy = function() {
      return new Constraint(this.pattern.copy(), this.expression.copy());
    };

    _Class.prototype.equals = function(other) {
      return this.pattern.equals(other.pattern, false) && this.expression.equals(other.expression, false);
    };

    return _Class;

  })();

  exports.ConstraintList = ConstraintList = (function() {
    function _Class() {
      var checkVariable, constraint, contents, variable, variablesIn, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3, _ref4;
      contents = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.contents = contents;
      this.nextNewVariableIndex = 0;
      checkVariable = (function(_this) {
        return function(variable) {
          if (/^v[0-9]+$/.test(variable.name)) {
            return _this.nextNewVariableIndex = Math.max(_this.nextNewVariableIndex, parseInt(variable.name.slice(1)) + 1);
          }
        };
      })(this);
      variablesIn = function(expression) {
        return expression.descendantsSatisfying(function(d) {
          return d.type === 'v';
        });
      };
      _ref2 = this.contents;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        constraint = _ref2[_i];
        _ref3 = variablesIn(constraint.pattern);
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          variable = _ref3[_j];
          checkVariable(variable);
        }
        _ref4 = variablesIn(constraint.expression);
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          variable = _ref4[_k];
          checkVariable(variable);
        }
      }
    }

    _Class.prototype.nextNewVariable = function() {
      return OM.simple("v" + (this.nextNewVariableIndex++));
    };

    _Class.prototype.length = function() {
      return this.contents.length;
    };

    _Class.prototype.copy = function() {
      var c, result;
      result = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(ConstraintList, (function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.contents;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          c = _ref2[_i];
          _results.push(c.copy());
        }
        return _results;
      }).call(this), function(){});
      result.nextNewVariableIndex = this.nextNewVariableIndex;
      return result;
    };

    _Class.prototype.indexAtWhich = function(predicate) {
      var constraint, index, _i, _len, _ref2;
      _ref2 = this.contents;
      for (index = _i = 0, _len = _ref2.length; _i < _len; index = ++_i) {
        constraint = _ref2[index];
        if (predicate(constraint)) {
          return index;
        }
      }
      return -1;
    };

    _Class.prototype.plus = function() {
      var constraint, constraints, index, result, _i, _len;
      constraints = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      result = this.copy();
      for (_i = 0, _len = constraints.length; _i < _len; _i++) {
        constraint = constraints[_i];
        index = result.indexAtWhich(function(c) {
          return c.equals(constraint, false);
        });
        if (index === -1) {
          result.contents.push(constraint);
        }
      }
      return result;
    };

    _Class.prototype.minus = function() {
      var constraint, constraints, index, result, _i, _len;
      constraints = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      result = this.copy();
      for (_i = 0, _len = constraints.length; _i < _len; _i++) {
        constraint = constraints[_i];
        index = result.indexAtWhich(function(c) {
          return c.equals(constraint, false);
        });
        if (index > -1) {
          result.contents.splice(index, 1);
        }
      }
      return result;
    };

    _Class.prototype.firstSatisfying = function(predicate) {
      var _ref2;
      return (_ref2 = this.contents[this.indexAtWhich(predicate)]) != null ? _ref2 : null;
    };

    _Class.prototype.firstPairSatisfying = function(predicate) {
      var constraint1, constraint2, index1, index2, _i, _j, _len, _len1, _ref2, _ref3;
      _ref2 = this.contents;
      for (index1 = _i = 0, _len = _ref2.length; _i < _len; index1 = ++_i) {
        constraint1 = _ref2[index1];
        _ref3 = this.contents;
        for (index2 = _j = 0, _len1 = _ref3.length; _j < _len1; index2 = ++_j) {
          constraint2 = _ref3[index2];
          if (index1 !== index2) {
            if (predicate(constraint1, constraint2)) {
              return [constraint1, constraint2];
            }
          }
        }
      }
      return null;
    };

    _Class.prototype.isFunction = function() {
      var constraint, seenSoFar, _i, _len, _ref2, _ref3;
      seenSoFar = [];
      _ref2 = this.contents;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        constraint = _ref2[_i];
        if (!isMetavariable(constraint.pattern)) {
          return false;
        }
        if (_ref3 = constraint.pattern.name, __indexOf.call(seenSoFar, _ref3) >= 0) {
          return false;
        }
        seenSoFar.push(constraint.pattern.name);
      }
      return true;
    };

    _Class.prototype.lookup = function(variable) {
      var constraint, _i, _len, _ref2;
      if (!(variable instanceof OM)) {
        variable = OM["var"](variable);
      }
      setMetavariable(variable);
      _ref2 = this.contents;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        constraint = _ref2[_i];
        if (constraint.pattern.equals(variable, false)) {
          return constraint.expression;
        }
      }
      return null;
    };

    _Class.prototype.apply = function(expression) {
      var metavariable, metavariables, result, value, _i, _len;
      result = expression.copy();
      metavariables = result.descendantsSatisfying(isMetavariable);
      for (_i = 0, _len = metavariables.length; _i < _len; _i++) {
        metavariable = metavariables[_i];
        if ((value = this.lookup(metavariable)) != null) {
          metavariable.replaceWith(value);
        }
      }
      return result;
    };

    _Class.prototype.equals = function(other) {
      var constraint, _i, _j, _len, _len1, _ref2, _ref3;
      _ref2 = this.contents;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        constraint = _ref2[_i];
        if (!other.firstSatisfying(function(c) {
          return c.equals(constraint);
        })) {
          return false;
        }
      }
      _ref3 = other.contents;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        constraint = _ref3[_j];
        if (!this.firstSatisfying(function(c) {
          return c.equals(constraint);
        })) {
          return false;
        }
      }
      return true;
    };

    return _Class;

  })();

  exports.findDifferencesBetween = findDifferencesBetween = function(expression1, expression2) {
    var differences, recur;
    differences = [];
    recur = function(A, B) {
      var Ac, Bc, child, index, _i, _len, _results;
      if (A.type !== B.type) {
        return differences.push(A.address(expression1));
      }
      if (A.type === 'bi') {
        Ac = [A.symbol].concat(__slice.call(A.variables), [A.body]);
        Bc = [B.symbol].concat(__slice.call(B.variables), [B.body]);
      } else {
        Ac = A.children;
        Bc = B.children;
      }
      if (Ac.length !== Bc.length || (Ac.length + Bc.length === 0 && !A.equals(B, false))) {
        return differences.push(A.address(expression1));
      } else {
        _results = [];
        for (index = _i = 0, _len = Ac.length; _i < _len; index = ++_i) {
          child = Ac[index];
          _results.push(recur(child, Bc[index]));
        }
        return _results;
      }
    };
    recur(expression1, expression2);
    return differences;
  };

  exports.parentAddresses = parentAddresses = function(addresses) {
    var address, results, serialized, _i, _j, _len, _len1, _results;
    results = [];
    for (_i = 0, _len = addresses.length; _i < _len; _i++) {
      address = addresses[_i];
      if (address.length === 0) {
        continue;
      }
      serialized = JSON.stringify(address.slice(0, -1));
      if (__indexOf.call(results, serialized) < 0) {
        results.push(serialized);
      }
    }
    if (results.length === 0) {
      return null;
    }
    _results = [];
    for (_j = 0, _len1 = results.length; _j < _len1; _j++) {
      address = results[_j];
      _results.push(JSON.parse(address));
    }
    return _results;
  };

  exports.partitionedAddresses = partitionedAddresses = function(expression) {
    var partition, recur;
    partition = [];
    recur = function(subexpression) {
      var child, found, part, _i, _j, _len, _len1, _ref2, _results;
      found = false;
      for (_i = 0, _len = partition.length; _i < _len; _i++) {
        part = partition[_i];
        if (subexpression.equals(part.subexpression, false)) {
          part.addresses.push(subexpression.address(expression));
          found = true;
          break;
        }
      }
      if (!found) {
        partition.push({
          subexpression: subexpression,
          addresses: [subexpression.address(expression)]
        });
      }
      _ref2 = subexpression.children;
      _results = [];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        child = _ref2[_j];
        _results.push(recur(child));
      }
      return _results;
    };
    recur(expression);
    return partition;
  };

  exports.expressionDepth = expressionDepth = function(expression) {
    var child, children;
    children = __slice.call(expression.children).concat(__slice.call(expression.variables));
    if (expression.body) {
      children.push(expression.body);
    }
    if (expression.symbol) {
      children.push(expression.symbol);
    }
    return 1 + Math.max.apply(Math, [0].concat(__slice.call(((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        child = children[_i];
        _results.push(expressionDepth(child));
      }
      return _results;
    })()))));
  };

  exports.sameDepthAncestors = sameDepthAncestors = function(expression, addresses) {
    var address, address1, address2, deeper, depth1, depth2, improvement, index1, index2, results, serialized, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _results;
    for (index1 = _i = 0, _len = addresses.length; _i < _len; index1 = ++_i) {
      address1 = addresses[index1];
      depth1 = expressionDepth(expression.index(address1));
      for (index2 = _j = 0, _len1 = addresses.length; _j < _len1; index2 = ++_j) {
        address2 = addresses[index2];
        depth2 = expressionDepth(expression.index(address2));
        if (depth1 === depth2) {
          continue;
        }
        if (depth1 > depth2) {
          _ref2 = [address2, address1], address1 = _ref2[0], address2 = _ref2[1];
          _ref3 = [index2, index1], index1 = _ref3[0], index2 = _ref3[1];
        }
        deeper = address1.slice(0, -1);
        improvement = addresses.slice(0);
        improvement[index1] = address1.slice(0, -1);
        return sameDepthAncestors(expression, improvement);
      }
    }
    results = [];
    for (_k = 0, _len2 = addresses.length; _k < _len2; _k++) {
      address = addresses[_k];
      serialized = JSON.stringify(address);
      if (__indexOf.call(results, serialized) < 0) {
        results.push(serialized);
      }
    }
    _results = [];
    for (_l = 0, _len3 = results.length; _l < _len3; _l++) {
      serialized = results[_l];
      _results.push(JSON.parse(serialized));
    }
    return _results;
  };

  exports.differenceIterator = differenceIterator = function(expression1, expression2) {
    var indexedSubexpressionsAreEqual, nextAddressSet;
    nextAddressSet = sameDepthAncestors(expression1, findDifferencesBetween(expression1, expression2));
    indexedSubexpressionsAreEqual = function(addresses) {
      var address1, address2, _i, _j, _len, _len1;
      for (_i = 0, _len = addresses.length; _i < _len; _i++) {
        address1 = addresses[_i];
        for (_j = 0, _len1 = addresses.length; _j < _len1; _j++) {
          address2 = addresses[_j];
          if (!expression1.index(address1).equals(expression1.index(address2), false)) {
            return false;
          }
          if (!expression2.index(address1).equals(expression2.index(address2), false)) {
            return false;
          }
        }
      }
      return true;
    };
    return function() {
      var pars, result;
      while ((nextAddressSet != null) && !indexedSubexpressionsAreEqual(nextAddressSet)) {
        pars = parentAddresses(nextAddressSet);
        nextAddressSet = pars && sameDepthAncestors(expression1, pars);
      }
      result = nextAddressSet;
      if (result !== null) {
        pars = parentAddresses(nextAddressSet);
        nextAddressSet = pars && sameDepthAncestors(expression1, pars);
      }
      return result;
    };
  };

  exports.subexpressionIterator = subexpressionIterator = function(expression) {
    var iterator, partition, state;
    partition = partitionedAddresses(expression);
    state = {
      next: partition.shift(),
      rest: partition,
      subsetIndex: 1
    };
    iterator = function() {
      var i, result, x;
      matchDebug('\t\tsubexpression iterator for', expression.simpleEncode(), 'next:', JSON.stringify(state.next.addresses), 'rest:', JSON.stringify((function() {
        var _i, _len, _ref2, _results;
        _ref2 = state.rest;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          x = _ref2[_i];
          _results.push(x.addresses);
        }
        return _results;
      })()), 'subsetIndex:', state.subsetIndex);
      if (state.subsetIndex < Math.pow(2, state.next.addresses.length)) {
        result = (function() {
          var _i, _ref2, _results;
          _results = [];
          for (i = _i = 0, _ref2 = state.next.addresses.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
            if (0 < (state.subsetIndex & Math.pow(2, i))) {
              _results.push(state.next.addresses[i]);
            }
          }
          return _results;
        })();
        state.subsetIndex++;
        return result;
      }
      if (state.rest.length > 0) {
        state.next = state.rest.shift();
        state.subsetIndex = 1;
        return iterator();
      }
      return null;
    };
    return iterator;
  };

  exports.prefixIterator = prefixIterator = function(element, iterator) {
    var firstCallHasHappened;
    firstCallHasHappened = false;
    return function() {
      if (firstCallHasHappened) {
        return iterator();
      }
      firstCallHasHappened = true;
      return element;
    };
  };

  exports.suffixIterator = suffixIterator = function(iterator, element) {
    var suffixHasHappened;
    suffixHasHappened = false;
    return function() {
      var result;
      result = iterator();
      if (result === null && !suffixHasHappened) {
        result = element;
        suffixHasHappened = true;
      }
      return result;
    };
  };

  exports.composeIterator = composeIterator = function(iterator, func) {
    return function() {
      var result;
      if (result = iterator()) {
        return func(result);
      } else {
        return null;
      }
    };
  };

  exports.filterIterator = filterIterator = function(iterator, filter) {
    return function() {
      var next;
      next = iterator();
      while (next && !filter(next)) {
        next = iterator();
      }
      return next;
    };
  };

  exports.concatenateIterators = concatenateIterators = function(first, second) {
    return function() {
      return first() || second();
    };
  };

  exports.multiReplace = multiReplace = function(expression, addresses, replacement) {
    var address, result, _i, _len, _ref2;
    result = expression.copy();
    for (_i = 0, _len = addresses.length; _i < _len; _i++) {
      address = addresses[_i];
      if ((_ref2 = result.index(address)) != null) {
        _ref2.replaceWith(replacement.copy());
      }
    }
    return result;
  };

  exports.bindingConstraints1 = bindingConstraints1 = function(pattern) {
    var already, binding, isBinder, m, newConstraint, result, v, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3, _ref4;
    result = new ConstraintList();
    isBinder = function(d) {
      return d.type === 'bi';
    };
    _ref2 = pattern.descendantsSatisfying(isBinder);
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      binding = _ref2[_i];
      _ref3 = binding.descendantsSatisfying(isMetavariable);
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        m = _ref3[_j];
        if (!m.isFree(binding)) {
          continue;
        }
        _ref4 = binding.variables;
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          v = _ref4[_k];
          if (!isMetavariable(v)) {
            continue;
          }
          newConstraint = new Constraint(v, m);
          already = function(c) {
            return c.equals(newConstraint);
          };
          if (!result.firstSatisfying(already)) {
            result.contents.push(newConstraint);
          }
        }
      }
    }
    return result;
  };

  exports.satisfiesBindingConstraints1 = satisfiesBindingConstraints1 = function(solution, constraints) {
    var constraint, sm, sv, _i, _len, _ref2;
    _ref2 = constraints.contents;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      constraint = _ref2[_i];
      sv = solution.lookup(constraint.pattern);
      sm = solution.lookup(constraint.expression).copy();
      if (sm.occursFree(sv)) {
        return false;
      }
    }
    return true;
  };

  exports.bindingConstraints2 = bindingConstraints2 = function(pattern) {
    var efa, newConstraint, result, _i, _len, _ref2;
    result = new ConstraintList();
    _ref2 = pattern.descendantsSatisfying(isExpressionFunctionApplication);
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      efa = _ref2[_i];
      if (!isMetavariable(efa.children[1])) {
        continue;
      }
      newConstraint = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Constraint, efa.children.slice(1, 3), function(){});
      if (!result.firstSatisfying(function(c) {
        return c.equals(newConstraint);
      })) {
        result.contents.push(newConstraint);
      }
    }
    return result;
  };

  exports.satisfiesBindingConstraints2 = satisfiesBindingConstraints2 = function(solution, constraints) {
    var arg, check, constraint, ef, v, _i, _j, _len, _len1, _ref2, _ref3;
    _ref2 = constraints.contents;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      constraint = _ref2[_i];
      ef = solution.lookup(constraint.pattern);
      if (ef == null) {
        matchDebug(CLToString(solution), CLToString(constraints));
      }
      arg = solution.apply(constraint.expression);
      check = function(d) {
        return d.equals(ef.variables[0]);
      };
      _ref3 = ef.body.descendantsSatisfying(check);
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        v = _ref3[_j];
        if (!arg.isFreeToReplace(v, ef.body)) {
          return false;
        }
      }
    }
    return true;
  };

  CToString = function(c) {
    return "(" + (c.pattern.simpleEncode()) + "," + (c.expression.simpleEncode()) + ")";
  };

  CLToString = function(cl) {
    var c;
    if (cl === null) {
      return null;
    }
    return "{ " + (((function() {
      var _i, _len, _ref2, _results;
      _ref2 = cl.contents;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        c = _ref2[_i];
        _results.push(CToString(c));
      }
      return _results;
    })()).join(', ')) + " }";
  };

  CLSetToString = function(cls) {
    var cl;
    if (cls === null) {
      return null;
    }
    return '[\n' + ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = cls.length; _i < _len; _i++) {
        cl = cls[_i];
        _results.push("\t" + (CLToString(cl)));
      }
      return _results;
    })()).join('\n') + '\n]';
  };

  matchDebugOn = false;

  exports.setMatchDebug = function(onoff) {
    return matchDebugOn = onoff;
  };

  matchDebug = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (matchDebugOn) {
      return console.log.apply(console, args);
    }
  };

  exports.nextMatch = nextMatch = function(constraints, solution, iterator) {
    var LHS, RHS, alreadySetTo, applied, c1, c2, child, constraint, e, e1, e2, index, leftChildren, mValue, makeMValue, metavariable, next, nextArguments, nextConstraints, nextIterator, nextResult, nextSolution, pair, pseudoChildren, rightChildren, smallerC, t, t1, t2, _ref2, _ref3;
    if (solution == null) {
      solution = new ConstraintList();
    }
    if (iterator == null) {
      iterator = null;
    }
    if (constraints instanceof Constraint) {
      constraints = new ConstraintList(constraints);
    }
    if (!(constraints instanceof ConstraintList)) {
      throw 'Invalid first parameter, not a constraint list';
    }
    matchDebug('\nmatchDebug', CLToString(constraints), CLToString(solution), iterator != null ? '  ...ITERATOR...' : '');
    if (iterator == null) {
      if (constraints.length() === 0) {
        matchDebug('\tbase case, returning:', CLToString(solution));
        return [solution, null];
      }
      constraint = constraints.firstSatisfying(function(c) {
        return c.pattern.children.length === 0 && c.pattern.variables.length === 0 && !isMetavariable(c.pattern);
      });
      if (constraint != null) {
        if (constraint.pattern.equals(constraint.expression, false)) {
          matchDebug('\tatomic case, recur:', CToString(constraint));
          return nextMatch(constraints.minus(constraint), solution, iterator);
        } else {
          matchDebug('\tatomic case, return null for', CToString(constraint));
          return [null, null];
        }
      }
      pseudoChildren = function(expr) {
        if (expr.type === 'bi') {
          return [expr.symbol].concat(__slice.call(expr.variables), [expr.body]);
        } else {
          return expr.children;
        }
      };
      constraint = constraints.firstSatisfying(function(c) {
        return pseudoChildren(c.pattern).length > 0 && !isExpressionFunctionApplication(c.pattern);
      });
      if (constraint != null) {
        LHS = constraint.pattern;
        RHS = constraint.expression;
        if (LHS.type !== RHS.type) {
          matchDebug('\tnon-atomic case, type fail:', CToString(constraint));
          return [null, null];
        }
        leftChildren = pseudoChildren(LHS);
        rightChildren = pseudoChildren(RHS);
        if (leftChildren.length !== rightChildren.length) {
          matchDebug('\tnon-atomic case, #children fail:', CToString(constraint));
          return [null, null];
        }
        constraints = (_ref2 = constraints.minus(constraint)).plus.apply(_ref2, (function() {
          var _i, _len, _results;
          _results = [];
          for (index = _i = 0, _len = leftChildren.length; _i < _len; index = ++_i) {
            child = leftChildren[index];
            _results.push(new Constraint(child, rightChildren[index]));
          }
          return _results;
        })());
        matchDebug('\tnon-atomic case, recur:', CToString(constraint));
        return nextMatch(constraints, solution, iterator);
      }
      constraint = constraints.firstSatisfying(function(c) {
        return isMetavariable(c.pattern);
      });
      if (constraint != null) {
        if (alreadySetTo = solution.lookup(constraint.pattern)) {
          if (!constraint.expression.equals(alreadySetTo, false)) {
            matchDebug('\tmetavariable case, mismatch:', CToString(constraint));
            return [null, null];
          } else {
            matchDebug('\tmetavariable case, already set:', CToString(constraint));
          }
        } else {
          matchDebug('\tmetavariable case, assigning:', CToString(constraint));
          solution = solution.plus(constraint.copy());
        }
        return nextMatch(constraints.minus(constraint), solution, iterator);
      }
      pair = constraints.firstPairSatisfying(function(c1, c2) {
        return isExpressionFunctionApplication(c1.pattern) && isExpressionFunctionApplication(c2.pattern) && c1.pattern.children[1].equals(c2.pattern.children[1], false) && !c1.expression.equals(c2.expression, false);
      });
      if (pair != null) {
        c1 = pair[0], c2 = pair[1];
        smallerC = constraints.minus(c1, c2);
        metavariable = c1.pattern.children[1];
        t1 = c1.pattern.children[2];
        t2 = c2.pattern.children[2];
        e1 = c1.expression;
        e2 = c2.expression;
        makeMValue = function(subset) {
          var v;
          v = constraints.nextNewVariable();
          return makeExpressionFunction(v, multiReplace(e1, subset, v));
        };
        iterator = differenceIterator(e1, e2);
        iterator = filterIterator(iterator, function(subset) {
          var mValue;
          mValue = solution.lookup(metavariable);
          return (mValue == null) || alphaEquivalent(mValue, makeMValue(subset));
        });
        iterator = composeIterator(iterator, function(subset) {
          var maybeExtended;
          maybeExtended = solution.lookup(metavariable) ? solution.copy() : solution.plus(new Constraint(metavariable, makeMValue(subset)));
          return [smallerC.plus(new Constraint(t1, e1.index(subset[0])), new Constraint(t2, e2.index(subset[0]))), maybeExtended, null];
        });
        matchDebug('\tefa case 1 of 2, iterating:', CToString(c1), CToString(c2));
        return nextMatch(smallerC, solution, iterator);
      }
      pair = constraints.firstPairSatisfying(function(c1, c2) {
        return isExpressionFunctionApplication(c1.pattern) && isExpressionFunctionApplication(c2.pattern) && c1.pattern.children[1].equals(c2.pattern.children[1], false) && c1.expression.equals(c2.expression, false);
      });
      if (pair != null) {
        c1 = pair[0], c2 = pair[1];
        smallerC = constraints.minus(c1, c2);
        metavariable = c1.pattern.children[1];
        t1 = c1.pattern.children[2];
        t2 = c2.pattern.children[2];
        e = c1.expression;
        makeMValue = function(subset) {
          var v;
          v = constraints.nextNewVariable();
          return makeExpressionFunction(v, multiReplace(e, subset, v));
        };
        iterator = subexpressionIterator(e);
        iterator = filterIterator(iterator, function(subset) {
          var mValue;
          mValue = solution.lookup(metavariable);
          return (mValue == null) || alphaEquivalent(mValue, makeMValue(subset));
        });
        iterator = suffixIterator(iterator, []);
        iterator = composeIterator(iterator, function(subset) {
          var maybeExtended, newConstraints, newMValue, oldMValue;
          newMValue = makeMValue(subset);
          if (oldMValue = solution.lookup(metavariable)) {
            if (!alphaEquivalent(oldMValue, newMValue)) {
              return null;
            }
            maybeExtended = solution.copy();
          } else {
            maybeExtended = solution.plus(new Constraint(metavariable, newMValue));
          }
          newConstraints = smallerC;
          if (subset.length !== 0) {
            newConstraints = newConstraints.plus(new Constraint(t1, e.index(subset[0])), new Constraint(t2, e.index(subset[0])));
          }
          return [newConstraints, maybeExtended, null];
        });
        matchDebug('\tefa case 2 of 2, iterating:', CToString(c1), CToString(c2));
        return nextMatch(smallerC, solution, iterator);
      }
      constraint = constraints.contents[0];
      if (!isExpressionFunctionApplication(constraint.pattern)) {
        throw Error('Invalid assumption in final case of matching');
      }
      smallerC = constraints.minus(constraint);
      metavariable = constraint.pattern.children[1];
      t = constraint.pattern.children[2];
      e = constraint.expression;
      if (mValue = solution.lookup(metavariable)) {
        applied = applyExpressionFunction(mValue, t);
        matchDebug('\tfinal case, applying known metavariable:', CToString(constraint));
        return nextMatch(smallerC.plus(new Constraint(mValue, e)), solution, iterator);
      }
      makeMValue = function(subset) {
        var v;
        v = constraints.nextNewVariable();
        return makeExpressionFunction(v, multiReplace(e, subset, v));
      };
      iterator = subexpressionIterator(e);
      iterator = filterIterator(iterator, function(subset) {
        mValue = solution.lookup(metavariable);
        return (mValue == null) || alphaEquivalent(mValue, makeMValue(subset));
      });
      iterator = suffixIterator(iterator, []);
      iterator = composeIterator(iterator, function(subset) {
        var maybeExtended, newConstraints, newMValue, oldMValue;
        matchDebug('\t\tnext subexpression, with subset', JSON.stringify(subset), 'solution', CLToString(solution), 'constraints', CLToString(smallerC), 't', t.simpleEncode(), 'e', e.simpleEncode(), 'metavariable', metavariable.simpleEncode());
        newMValue = makeMValue(subset);
        if (oldMValue = solution.lookup(metavariable)) {
          if (!alphaEquivalent(oldMValue, newMValue)) {
            return null;
          }
          maybeExtended = solution.copy();
        } else {
          maybeExtended = solution.plus(new Constraint(metavariable, newMValue));
        }
        newConstraints = smallerC;
        if (subset.length !== 0) {
          newConstraints = newConstraints.plus(new Constraint(t, e.index(subset[0])));
        }
        return [newConstraints, maybeExtended, null];
      });
      matchDebug('\tfinal case, iterating:', CToString(constraint));
      return nextMatch(smallerC, solution, iterator);
    } else {
      next = iterator();
      if (next === null) {
        matchDebug('\titerator case, next is null, done!');
        return [null, null];
      }
      nextConstraints = next[0], nextSolution = next[1], nextIterator = next[2];
      matchDebug('\titerator case, using iterator.next():', CLToString(nextConstraints), CLToString(nextSolution), nextIterator != null, '\n--->');
      _ref3 = nextMatch(nextConstraints, nextSolution, nextIterator), nextResult = _ref3[0], nextArguments = _ref3[1];
      if (nextResult == null) {
        matchDebug('\n<---\n' + '\tafter iterator recursion, no result; keep iterating...');
        return nextMatch(constraints, solution, iterator);
      }
      if (nextArguments == null) {
        matchDebug('\n<---\n\tafter iterator recursion, ' + 'got a unique solution:', CLToString(nextResult));
        return [nextResult, [constraints, solution, iterator]];
      }
      matchDebug('\n<---\n\tafter iterator recursion, ' + 'got a(nother?) solution:', CLToString(nextResult), 'PLUS nextArguments', CLToString(nextArguments[0]), CLToString(nextArguments[1]), nextArguments[2] != null);
      nextArguments[2] = concatenateIterators(nextArguments[2], iterator);
      return [nextResult, nextArguments];
    }
  };

}).call(this);

//# sourceMappingURL=matching-duo.js.map
