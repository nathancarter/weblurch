// Generated by CoffeeScript 1.8.0
(function() {
  var Dependencies, Dialogs, Dropbox, Group, Groups, LoadSave, Overlay, createFontStyleString, createStyleString, editor, embedMetadata, exportPage, extractMetadata, formatContentForWiki, getAPIPage, getIndexPage, getPageContent, getPageData, getPageMetadata, getPageTimestamp, grouperHTML, grouperInfo, htmlToImage, importPage, installClickListener, login, maybeSetupTestRecorder, moreMenuItems, moreToolbarItems, plugin, prepareHTML, setAPIPage, setIndexPage,
    __hasProp = {}.hasOwnProperty,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Dependencies = (function() {
    function Dependencies(editor) {
      this.editor = editor;
      this.length = 0;
    }

    Dependencies.prototype.getFileMetadata = function(filepath, filename) {
      var tmp;
      if (filename === null) {
        return;
      }
      if (filepath === null) {
        filepath = '.';
      }
      tmp = new FileSystem(this.editor.LoadSave.fileSystem);
      tmp.cd(filepath);
      return tmp.read(filename)[1];
    };

    Dependencies.prototype["import"] = function(dependencies) {
      var i, _i, _j, _ref, _ref1;
      for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        delete this[i];
      }
      for (i = _j = 0, _ref1 = this.length = dependencies.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        this[i] = JSON.parse(JSON.stringify(dependencies[i]));
      }
      return this.update();
    };

    Dependencies.prototype["export"] = function() {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(JSON.parse(JSON.stringify(this[i])));
      }
      return _results;
    };

    Dependencies.prototype.update = function(index) {
      var dependency, filename, filepath, i, newData, pageName, splitPoint;
      if (index == null) {
        return (function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(this.update(i));
          }
          return _results;
        }).call(this);
      }
      if (!(index >= 0 && index < this.length)) {
        return;
      }
      dependency = this[index];
      if (dependency.address.slice(0, 7) === 'file://') {
        splitPoint = dependency.address.lastIndexOf('/');
        filename = dependency.address.slice(splitPoint);
        filepath = dependency.address.slice(7, splitPoint);
        newData = this.getFileMetadata(filepath, filename).exports;
        if (JSON.stringify(newData) !== JSON.stringify(this[index])) {
          this[index].data = newData;
          this[index].date = new Date;
          return this.editor.fire('dependenciesChanged');
        }
      } else if (dependency.address.slice(0, 7) === 'wiki://') {
        pageName = dependency.address.slice(7);
        return this.editor.MediaWiki.getPageTimestamp(pageName, (function(_this) {
          return function(result, error) {
            var currentVersion, lastModified;
            if (result == null) {
              return;
            }
            lastModified = new Date(result);
            currentVersion = new Date(dependency.date);
            if (!(lastModified > currentVersion)) {
              return;
            }
            return _this.editor.MediaWiki.getPageMetadata(pageName, function(metadata) {
              if ((metadata != null) && JSON.stringify(_this[index]) !== JSON.stringify(metadata.exports)) {
                _this[index].data = metadata.exports;
                _this[index].date = lastModified;
                return _this.editor.fire('dependenciesChanged');
              }
            });
          };
        })(this));
      } else {
        return this.editor.fire('dependenciesChanged');
      }
    };

    Dependencies.prototype.add = function(address, callback) {
      var e, filename, filepath, newData, pageName, splitPoint;
      if (address.slice(0, 7) === 'file://') {
        splitPoint = address.lastIndexOf('/');
        filename = address.slice(splitPoint);
        filepath = address.slice(7, splitPoint);
        try {
          newData = this.getFileMetadata(filepath, filename).exports;
          this[this.length++] = {
            address: address,
            data: newData,
            date: new Date
          };
          if (typeof callback === "function") {
            callback(newData, null);
          }
          return this.editor.fire('dependenciesChanged');
        } catch (_error) {
          e = _error;
          return typeof callback === "function" ? callback(null, e) : void 0;
        }
      } else if (address.slice(0, 7) === 'wiki://') {
        pageName = address.slice(7);
        return this.editor.MediaWiki.getPageTimestamp(pageName, (function(_this) {
          return function(result, error) {
            if (result == null) {
              return typeof callback === "function" ? callback(null, 'Could not get wiki page timestamp') : void 0;
            }
            return _this.editor.MediaWiki.getPageMetadata(pageName, function(metadata) {
              if (metadata == null) {
                return typeof callback === "function" ? callback(null, 'Could not access wiki page') : void 0;
              }
              _this[_this.length++] = {
                address: address,
                data: metadata.exports,
                date: new Date(result)
              };
              if (typeof callback === "function") {
                callback(metadata.exports, null);
              }
              return _this.editor.fire('dependenciesChanged');
            });
          };
        })(this));
      }
    };

    Dependencies.prototype.remove = function(index) {
      var i, _i, _ref;
      if (!(index >= 0 && index < this.length)) {
        return;
      }
      for (i = _i = index, _ref = this.length - 1; index <= _ref ? _i < _ref : _i > _ref; i = index <= _ref ? ++_i : --_i) {
        this[i] = this[i + 1];
      }
      delete this[--this.length];
      return this.editor.fire('dependenciesChanged');
    };

    Dependencies.prototype.installUI = function(div) {
      var dependency, elt, index, parts, _i, _j, _len, _len1;
      parts = [];
      for (index = _i = 0, _len = this.length; _i < _len; index = ++_i) {
        dependency = this[index];
        parts.push(this.editor.Settings.UI.generalPair(dependency.address, this.editor.Settings.UI.button('Remove', "dependencyRemove" + index), "dependencyRow" + index, 80, 'center'));
      }
      if (this.length === 0) {
        parts.push(this.editor.Settings.UI.info('(no dependencies)'));
      }
      parts.push(this.editor.Settings.UI.info("" + (this.editor.Settings.UI.button('Add file dependency', 'dependencyAddFile')) + " " + (this.editor.Settings.UI.button('Add wiki page dependency', 'dependencyAddWiki'))));
      div.innerHTML = parts.join('\n');
      elt = function(id) {
        return div.ownerDocument.getElementById(id);
      };
      for (index = _j = 0, _len1 = this.length; _j < _len1; index = ++_j) {
        dependency = this[index];
        elt("dependencyRemove" + index).addEventListener('click', (function(_this) {
          return function(index) {
            return function() {
              _this.remove(index);
              return _this.installUI(div);
            };
          };
        })(this)(index));
      }
      elt('dependencyAddFile').addEventListener('click', (function(_this) {
        return function() {
          return _this.editor.LoadSave.tryToOpen(function(path, file) {
            if (file != null) {
              if (path != null) {
                path += '/';
              } else {
                path = '';
              }
              return _this.add("file://" + path + file, function(result, error) {
                if (error != null) {
                  return _this.editor.Dialogs.alert({
                    title: 'Error adding dependency',
                    message: error
                  });
                } else {
                  return _this.installUI(div);
                }
              });
            }
          });
        };
      })(this));
      return elt('dependencyAddWiki').addEventListener('click', (function(_this) {
        return function() {
          var url;
          if (url = prompt('Enter the wiki page name of the dependency to add.', 'Example Page Name')) {
            return _this.add("wiki://" + url, function(result, error) {
              if (error != null) {
                return _this.editor.Dialogs.alert({
                  title: 'Error adding dependency',
                  message: error
                });
              } else {
                return _this.installUI(div);
              }
            });
          }
        };
      })(this));
    };

    return Dependencies;

  })();

  tinymce.PluginManager.add('dependencies', function(editor, url) {
    return editor.Dependencies = new Dependencies(editor);
  });

  Dialogs = {};

  prepareHTML = function(html) {
    var script;
    script = function() {
      var install, _ref;
      install = function(tagName, eventName) {
        var element, _i, _len, _ref, _results;
        _ref = document.getElementsByTagName(tagName);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          element = _ref[_i];
          _results.push(element.addEventListener(eventName, function(event) {
            return top.postMessage({
              value: event.currentTarget.value,
              id: event.currentTarget.getAttribute('id')
            }, '*');
          }));
        }
        return _results;
      };
      install('a', 'click');
      install('input', 'click');
      install('input', 'input');
      return (_ref = document.getElementsByTagName('input')[0]) != null ? _ref.focus() : void 0;
    };
    return window.objectURLForBlob(window.makeBlob(html + ("<script>(" + script + ")()</script>"), 'text/html;charset=utf-8'));
  };

  installClickListener = function(handler) {
    var innerHandler;
    innerHandler = function(event) {
      return handler(event.data);
    };
    window.addEventListener('message', innerHandler, false);
    return tinymce.activeEditor.windowManager.getWindows()[0].on('close', function() {
      return window.removeEventListener('message', innerHandler);
    });
  };

  Dialogs.alert = function(options) {
    var dialog, _ref, _ref1, _ref2;
    dialog = tinymce.activeEditor.windowManager.open({
      title: (_ref = options.title) != null ? _ref : ' ',
      url: prepareHTML(options.message),
      width: (_ref1 = options.width) != null ? _ref1 : 400,
      height: (_ref2 = options.height) != null ? _ref2 : 300,
      buttons: [
        {
          type: 'button',
          text: 'OK',
          subtype: 'primary',
          onclick: function(event) {
            dialog.close();
            return typeof options.callback === "function" ? options.callback(event) : void 0;
          }
        }
      ]
    });
    if (options.onclick) {
      return installClickListener(options.onclick);
    }
  };

  Dialogs.confirm = function(options) {
    var dialog, _ref, _ref1, _ref2, _ref3, _ref4;
    dialog = tinymce.activeEditor.windowManager.open({
      title: (_ref = options.title) != null ? _ref : ' ',
      url: prepareHTML(options.message),
      width: (_ref1 = options.width) != null ? _ref1 : 400,
      height: (_ref2 = options.height) != null ? _ref2 : 300,
      buttons: [
        {
          type: 'button',
          text: (_ref3 = options.Cancel) != null ? _ref3 : 'Cancel',
          subtype: 'primary',
          onclick: function(event) {
            dialog.close();
            return typeof options.cancelCallback === "function" ? options.cancelCallback(event) : void 0;
          }
        }, {
          type: 'button',
          text: (_ref4 = options.OK) != null ? _ref4 : 'OK',
          subtype: 'primary',
          onclick: function(event) {
            dialog.close();
            return typeof options.okCallback === "function" ? options.okCallback(event) : void 0;
          }
        }
      ]
    });
    if (options.onclick) {
      return installClickListener(options.onclick);
    }
  };

  Dialogs.prompt = function(options) {
    var dialog, lastValue, value, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    value = options.value ? " value='" + options.value + "'" : '';
    options.message += "<p><input type='text' " + value + " id='promptInput' size=40/></p>";
    lastValue = (_ref = options.value) != null ? _ref : '';
    dialog = tinymce.activeEditor.windowManager.open({
      title: (_ref1 = options.title) != null ? _ref1 : ' ',
      url: prepareHTML(options.message),
      width: (_ref2 = options.width) != null ? _ref2 : 300,
      height: (_ref3 = options.height) != null ? _ref3 : 200,
      buttons: [
        {
          type: 'button',
          text: (_ref4 = options.Cancel) != null ? _ref4 : 'Cancel',
          subtype: 'primary',
          onclick: function(event) {
            dialog.close();
            return typeof options.cancelCallback === "function" ? options.cancelCallback(lastValue) : void 0;
          }
        }, {
          type: 'button',
          text: (_ref5 = options.OK) != null ? _ref5 : 'OK',
          subtype: 'primary',
          onclick: function(event) {
            dialog.close();
            return typeof options.okCallback === "function" ? options.okCallback(lastValue) : void 0;
          }
        }
      ]
    });
    return installClickListener(function(data) {
      if (data.id === 'promptInput') {
        return lastValue = data.value;
      }
    });
  };

  Dialogs.codeEditor = function(options) {
    var dialog, handler, html, setup, whichCallback, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    setup = function(language) {
      var handler;
      window.codeEditor = CodeMirror.fromTextArea(document.getElementById('editor'), {
        lineNumbers: true,
        fullScreen: true,
        autofocus: true,
        theme: 'base16-light',
        mode: language
      });
      handler = function(event) {
        if (event.data === 'getEditorContents') {
          return top.postMessage(window.codeEditor.getValue(), '*');
        }
      };
      return window.addEventListener('message', handler, false);
    };
    html = "<html><head> <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.17.0/codemirror.min.css'> <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.17.0/theme/base16-light.min.css'> <script src='https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.17.0/codemirror.min.js'></script> <script src='https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.17.0/addon/display/fullscreen.min.js'></script> <script src='https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.17.0/mode/javascript/javascript.min.js'></script> </head> <body style='margin: 0px;'> <textarea id='editor'>" + ((_ref = options.value) != null ? _ref : '') + "</textarea> <script> (" + setup + ")(\"" + ((_ref1 = options.language) != null ? _ref1 : 'javascript') + "\") </script> </body></html>";
    whichCallback = null;
    dialog = tinymce.activeEditor.windowManager.open({
      title: (_ref2 = options.title) != null ? _ref2 : 'Code editor',
      url: window.objectURLForBlob(window.makeBlob(html, 'text/html;charset=utf-8')),
      width: (_ref3 = options.width) != null ? _ref3 : 700,
      height: (_ref4 = options.height) != null ? _ref4 : 500,
      buttons: [
        {
          type: 'button',
          text: (_ref5 = options.Cancel) != null ? _ref5 : 'Discard',
          subtype: 'primary',
          onclick: function(event) {
            whichCallback = options.cancelCallback;
            return dialog.getContentWindow().postMessage('getEditorContents', '*');
          }
        }, {
          type: 'button',
          text: (_ref6 = options.OK) != null ? _ref6 : 'Save',
          subtype: 'primary',
          onclick: function(event) {
            whichCallback = options.okCallback;
            return dialog.getContentWindow().postMessage('getEditorContents', '*');
          }
        }
      ]
    });
    handler = function(event) {
      dialog.close();
      return typeof whichCallback === "function" ? whichCallback(event.data) : void 0;
    };
    window.addEventListener('message', handler, false);
    return dialog.on('close', function() {
      return window.removeEventListener('message', handler);
    });
  };

  Dialogs.waiting = function(options) {
    var dialog, _ref, _ref1, _ref2;
    dialog = tinymce.activeEditor.windowManager.open({
      title: (_ref = options.title) != null ? _ref : ' ',
      url: prepareHTML(options.message),
      width: (_ref1 = options.width) != null ? _ref1 : 300,
      height: (_ref2 = options.height) != null ? _ref2 : 100,
      buttons: []
    });
    if (options.onclick) {
      installClickListener(options.onclick);
    }
    return options.work(function() {
      return dialog.close();
    });
  };

  tinymce.PluginManager.add('dialogs', function(editor, url) {
    return editor.Dialogs = Dialogs;
  });

  Dropbox = (function() {
    function Dropbox(editor) {
      this.editor = editor;
      this.editor.on('init', (function(_this) {
        return function() {};
      })(this));
    }

    Dropbox.prototype.openHandler = function() {
      return window.Dropbox.choose({
        success: (function(_this) {
          return function(files) {
            return $.ajax({
              url: files[0].link,
              success: function(result) {
                var depth, document, interior, match, metadata, munge, nextDivTag, open, rest, start, _ref;
                open = '<div id="EmbeddedLurchDocument">';
                start = result.indexOf(open);
                if (start > -1) {
                  start += open.length;
                  rest = result.substring(start);
                  interior = '';
                  munge = function(n) {
                    interior += rest.substring(0, n);
                    return rest = rest.substring(n);
                  };
                  nextDivTag = /<\s*([/]?)\s*div(>|\s+)/i;
                  depth = 1;
                  while (match = nextDivTag.exec(rest)) {
                    munge(match.index);
                    if (match[1] === '/') {
                      depth--;
                    } else {
                      depth++;
                    }
                    if (depth === 0) {
                      rest = '';
                      break;
                    } else {
                      munge(match[0].length);
                    }
                  }
                  munge(rest.length);
                  result = interior;
                }
                _ref = extractMetadata(result), metadata = _ref.metadata, document = _ref.document;
                tinymce.activeEditor.setContent(document);
                if (metadata != null) {
                  _this.loadMetaData(metadata);
                }
                return _this.setFilename(files[0].name);
              },
              error: function(jqxhr, message, error) {
                return editor.Dialogs.alert({
                  title: 'File load error',
                  message: "<h1>Error loading file</h1> <p>The file failed to load from the URL Dropbox provided, with an error of type " + message + ".</p>"
                });
              }
            });
          };
        })(this),
        linkType: 'direct',
        multiselect: false
      });
    };

    Dropbox.prototype.saveHandler = function() {
      var content, url;
      content = embedMetadata(editor.getContent(), this.saveMetaData());
      content = '<div id="EmbeddedLurchDocument">' + content + ("</div> <script> window.location.href = '" + (window.location.href.split('?')[0]) + "' + '?document=' + encodeURIComponent( EmbeddedLurchDocument.innerHTML ); </script>");
      url = 'data:text/html,' + encodeURIComponent(content);
      console.log(document, content, url);
      if (editor.LoadSave.filename == null) {
        this.setFilename(prompt('Choose a filename', 'My Lurch Document.html'));
        if (this.filename == null) {
          editor.Dialogs.alert({
            title: 'Saving requires a filename',
            message: 'You must specify a filename before you can save the file into your Dropbox.'
          });
          return;
        }
      }
      return window.Dropbox.save(url, this.filename, {
        success: (function(_this) {
          return function() {
            editor.Dialogs.alert({
              title: 'File saved successfully.',
              message: "<h1>Saved successfully.</h1> <p>File saved to Dropbox:<br> " + _this.filename + "</p>"
            });
            return _this.setDocumentDirty(false);
          };
        })(this),
        error: (function(_this) {
          return function(message) {
            return editor.Dialogs.alert({
              title: 'Error saving file',
              message: "<h1>File not saved!</h1> <p>File NOT saved to Dropbox:<br> " + _this.filename + "</p> <p>Reason: " + message + "</p>"
            });
          };
        })(this)
      });
    };

    Dropbox.prototype.manageFilesHandler = function() {
      return window.location.href = 'https://www.dropbox.com';
    };

    return Dropbox;

  })();

  tinymce.PluginManager.add('dropbox', function(editor, url) {
    return editor.Dropbox = new Dropbox(editor);
  });

  grouperHTML = function(typeName, openClose, id, hide, image) {
    if (hide == null) {
      hide = true;
    }
    hide = hide ? ' hide' : '';
    if (image == null) {
      image = "images/red-bracket-" + openClose + ".png";
    }
    return "<img src='" + image + "' class='grouper " + typeName + hide + "' id='" + openClose + id + "'>";
  };

  window.grouperHTML = grouperHTML;

  grouperInfo = function(grouper) {
    var info, more, result;
    info = /^(open|close)([0-9]+)$/.exec(grouper != null ? typeof grouper.getAttribute === "function" ? grouper.getAttribute('id') : void 0 : void 0);
    if (!info) {
      return null;
    }
    result = {
      openOrClose: info[1],
      id: parseInt(info[2])
    };
    more = /^grouper ([^ ]+)/.exec(grouper != null ? typeof grouper.getAttribute === "function" ? grouper.getAttribute('class') : void 0 : void 0);
    if (more) {
      result.type = more[1];
    }
    return result;
  };

  window.grouperInfo = grouperInfo;

  createStyleString = function(styleObject) {
    var key, letter, newkey, result, value, _i, _len;
    if (styleObject == null) {
      styleObject = window.defaultEditorStyles;
    }
    result = [];
    for (key in styleObject) {
      if (!__hasProp.call(styleObject, key)) continue;
      value = styleObject[key];
      newkey = '';
      for (_i = 0, _len = key.length; _i < _len; _i++) {
        letter = key[_i];
        if (letter.toUpperCase() === letter) {
          newkey += '-';
        }
        newkey += letter.toLowerCase();
      }
      result.push("" + newkey + ":" + value + ";");
    }
    return result.join(' ');
  };

  htmlToImage = function(html) {
    return objectURLForBlob(svgBlobForHTML(html, createStyleString()));
  };

  createFontStyleString = function(element) {
    var style;
    style = element.ownerDocument.defaultView.getComputedStyle(element);
    return "font-size:" + style.fontSize + "; font-family:" + style.fontFamily + ";";
  };

  Group = (function() {
    function Group(open, close, plugin) {
      var editor, _i, _len, _ref;
      this.open = open;
      this.close = close;
      this.plugin = plugin;
      this.getScreenBoundaries = __bind(this.getScreenBoundaries, this);
      this.connectionsIn = __bind(this.connectionsIn, this);
      this.connectionsOut = __bind(this.connectionsOut, this);
      this.disconnect = __bind(this.disconnect, this);
      this.connect = __bind(this.connect, this);
      this.toJSON = __bind(this.toJSON, this);
      this.contentsChanged = __bind(this.contentsChanged, this);
      this.nextSibling = __bind(this.nextSibling, this);
      this.previousSibling = __bind(this.previousSibling, this);
      this.indexInParent = __bind(this.indexInParent, this);
      this.groupAsHTML = __bind(this.groupAsHTML, this);
      this.remove = __bind(this.remove, this);
      this.rangeAfter = __bind(this.rangeAfter, this);
      this.rangeBefore = __bind(this.rangeBefore, this);
      this.outerRange = __bind(this.outerRange, this);
      this.innerRange = __bind(this.innerRange, this);
      this.setContentAsText = __bind(this.setContentAsText, this);
      this.contentNodes = __bind(this.contentNodes, this);
      this.contentAsHTML = __bind(this.contentAsHTML, this);
      this.contentAsFragment = __bind(this.contentAsFragment, this);
      this.contentAsText = __bind(this.contentAsText, this);
      this.updateGrouper = __bind(this.updateGrouper, this);
      this.clear = __bind(this.clear, this);
      this.keys = __bind(this.keys, this);
      this.get = __bind(this.get, this);
      this.set = __bind(this.set, this);
      this.type = __bind(this.type, this);
      this.typeName = __bind(this.typeName, this);
      this.id = __bind(this.id, this);
      if (this.plugin == null) {
        _ref = tinymce.editors;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          editor = _ref[_i];
          if (editor.getDoc() === this.open.ownerDocument) {
            this.plugin = editor.Groups;
            break;
          }
        }
      }
      this.contentsChanged(true, true);
    }

    Group.prototype.id = function() {
      var _ref, _ref1;
      return (_ref = (_ref1 = grouperInfo(this.open)) != null ? _ref1.id : void 0) != null ? _ref : null;
    };

    Group.prototype.typeName = function() {
      var _ref;
      return (_ref = grouperInfo(this.open)) != null ? _ref.type : void 0;
    };

    Group.prototype.type = function() {
      var _ref, _ref1;
      return (_ref = this.plugin) != null ? (_ref1 = _ref.groupTypes) != null ? _ref1[this.typeName()] : void 0 : void 0;
    };

    Group.prototype.set = function(key, value) {
      var attr, grouper, toStore, _i, _len, _ref, _results;
      if (!/^[a-zA-Z0-9-_]+$/.test(key)) {
        return;
      }
      toStore = JSON.stringify([value]);
      if (this.open.getAttribute("data-" + key) !== toStore) {
        this.open.setAttribute("data-" + key, toStore);
        if (this.plugin != null) {
          this.plugin.editor.fire('change');
          this.plugin.editor.isNotDirty = false;
          this.contentsChanged();
        }
        if (key === 'openDecoration' || key === 'closeDecoration') {
          this.updateGrouper(key.slice(0, -10));
        }
        if (key === 'openHoverText' || key === 'closeHoverText') {
          grouper = this[key.slice(0, -9)];
          _ref = ['title', 'alt'];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            attr = _ref[_i];
            _results.push(grouper.setAttribute(attr, "" + value));
          }
          return _results;
        }
      }
    };

    Group.prototype.get = function(key) {
      var e;
      try {
        return JSON.parse(this.open.getAttribute("data-" + key))[0];
      } catch (_error) {
        e = _error;
        return void 0;
      }
    };

    Group.prototype.keys = function() {
      return Object.keys(this.open.dataset);
    };

    Group.prototype.clear = function(key) {
      var attr, grouper, _i, _len, _ref, _results;
      if (!/^[a-zA-Z0-9-_]+$/.test(key)) {
        return;
      }
      if (this.open.getAttribute("data-" + key) != null) {
        this.open.removeAttribute("data-" + key);
        if (this.plugin != null) {
          this.plugin.editor.fire('change');
          this.plugin.editor.isNotDirty = false;
          this.contentsChanged();
        }
        if (key === 'openDecoration' || key === 'closeDecoration') {
          this.updateGrouper(key.slice(0, -10));
        }
        if (key === 'openHoverText' || key === 'closeHoverText') {
          grouper = this[key.slice(0, -9)];
          _ref = ['title', 'alt'];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            attr = _ref[_i];
            _results.push(grouper.removeAttribute(attr));
          }
          return _results;
        }
      }
    };

    Group.prototype.updateGrouper = function(openOrClose) {
      var decoration, grouper, html, jquery, _ref;
      if (openOrClose === this.open) {
        openOrClose = 'open';
      }
      if (openOrClose === this.close) {
        openOrClose = 'close';
      }
      if (openOrClose !== 'open' && openOrClose !== 'close') {
        return;
      }
      jquery = $(grouper = this[openOrClose]);
      if ((decoration = this.get("" + openOrClose + "Decoration")) != null) {
        jquery.addClass('decorate');
      } else {
        jquery.removeClass('decorate');
        decoration = '';
      }
      html = jquery.hasClass('hide') ? '' : (_ref = this.type()) != null ? _ref["" + openOrClose + "ImageHTML"] : void 0;
      if (openOrClose === 'open') {
        html = decoration + html;
      } else {
        html += decoration;
      }
      return window.base64URLForBlob(window.svgBlobForHTML(html, createFontStyleString(grouper)), (function(_this) {
        return function(base64) {
          var _ref1, _ref2;
          if (grouper.getAttribute('src') !== base64) {
            grouper.setAttribute('src', base64);
            return (_ref1 = _this.plugin) != null ? (_ref2 = _ref1.editor.Overlay) != null ? _ref2.redrawContents() : void 0 : void 0;
          }
        };
      })(this));
    };

    Group.prototype.contentAsText = function() {
      var _ref;
      return (_ref = this.innerRange()) != null ? _ref.toString() : void 0;
    };

    Group.prototype.contentAsFragment = function() {
      var _ref;
      return (_ref = this.innerRange()) != null ? _ref.cloneContents() : void 0;
    };

    Group.prototype.contentAsHTML = function() {
      var fragment, tmp;
      if (!(fragment = this.contentAsFragment())) {
        return null;
      }
      tmp = this.open.ownerDocument.createElement('div');
      tmp.appendChild(fragment);
      return tmp.innerHTML;
    };

    Group.prototype.contentNodes = function() {
      var result, walk;
      result = [];
      walk = this.open;
      while (walk != null) {
        if (strictNodeOrder(walk, this.close)) {
          if (strictNodeOrder(this.open, walk)) {
            result.push(walk);
          }
          if (walk.nextSibling != null) {
            walk = walk.nextSibling;
          } else {
            walk = walk.parentNode;
          }
          continue;
        }
        if (strictNodeOrder(this.close, walk)) {
          console.log('Warning!! walked past @close...something is wrong with this loop');
          break;
        }
        if (walk === this.close) {
          break;
        } else {
          walk = walk.childNodes[0];
        }
      }
      return result;
    };

    Group.prototype.setContentAsText = function(text) {
      var inside, _ref, _ref1;
      if (!(inside = this.innerRange())) {
        return;
      }
      if ((_ref = this.plugin) != null) {
        _ref.editor.selection.setRng(inside);
      }
      return (_ref1 = this.plugin) != null ? _ref1.editor.selection.setContent(text) : void 0;
    };

    Group.prototype.innerRange = function() {
      var e, range;
      range = this.open.ownerDocument.createRange();
      try {
        range.setStartAfter(this.open);
        range.setEndBefore(this.close);
        return range;
      } catch (_error) {
        e = _error;
        return null;
      }
    };

    Group.prototype.outerRange = function() {
      var e, range;
      range = this.open.ownerDocument.createRange();
      try {
        range.setStartBefore(this.open);
        range.setEndAfter(this.close);
        return range;
      } catch (_error) {
        e = _error;
        return null;
      }
    };

    Group.prototype.rangeBefore = function() {
      var doc, e, prev, range;
      range = (doc = this.open.ownerDocument).createRange();
      try {
        range.setEndBefore(this.open);
        if (prev = this.previousSibling()) {
          range.setStartAfter(prev.close);
        } else if (this.parent) {
          range.setStartAfter(this.parent.open);
        } else {
          range.setStartBefore(doc.body.childNodes[0]);
        }
        return range;
      } catch (_error) {
        e = _error;
        return null;
      }
    };

    Group.prototype.rangeAfter = function() {
      var doc, e, next, range;
      range = (doc = this.open.ownerDocument).createRange();
      try {
        range.setStartAfter(this.close);
        if (next = this.nextSibling()) {
          range.setEndBefore(next.open);
        } else if (this.parent) {
          range.setEndBefore(this.parent.close);
        } else {
          range.setEndAfter(doc.body.childNodes[doc.body.childNodes.length - 1]);
        }
        return range;
      } catch (_error) {
        e = _error;
        return null;
      }
    };

    Group.prototype.remove = function() {
      var cxn, _i, _j, _len, _len1, _ref, _ref1;
      if (!this.plugin) {
        return;
      }
      _ref = this.connectionsIn();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        cxn = _ref[_i];
        this.disconnect(this.plugin[cxn[0]]);
      }
      _ref1 = this.connectionsOut();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        cxn = _ref1[_j];
        this.disconnect(this.plugin[cxn[1]]);
      }
      return this.plugin.editor.undoManager.transact((function(_this) {
        return function() {
          return ($([_this.open].concat(__slice.call(_this.contentNodes()), [_this.close]))).remove();
        };
      })(this));
    };

    Group.prototype.groupAsHTML = function(withSrcAttributes) {
      var fragment, tmp, _ref;
      if (withSrcAttributes == null) {
        withSrcAttributes = true;
      }
      if (!(fragment = (_ref = this.outerRange()) != null ? _ref.cloneContents() : void 0)) {
        return null;
      }
      tmp = this.open.ownerDocument.createElement('div');
      tmp.appendChild(fragment);
      if (!withSrcAttributes) {
        ($(tmp)).find('.grouper').removeAttr('src');
      }
      return tmp.innerHTML;
    };

    Group.prototype.indexInParent = function() {
      var _ref, _ref1, _ref2, _ref3;
      return (_ref = (_ref1 = (_ref2 = this.parent) != null ? _ref2.children : void 0) != null ? _ref1 : (_ref3 = this.plugin) != null ? _ref3.topLevel : void 0) != null ? _ref.indexOf(this) : void 0;
    };

    Group.prototype.previousSibling = function() {
      var _ref, _ref1, _ref2, _ref3;
      return (_ref = (_ref1 = (_ref2 = this.parent) != null ? _ref2.children : void 0) != null ? _ref1 : (_ref3 = this.plugin) != null ? _ref3.topLevel : void 0) != null ? _ref[this.indexInParent() - 1] : void 0;
    };

    Group.prototype.nextSibling = function() {
      var _ref, _ref1, _ref2, _ref3;
      return (_ref = (_ref1 = (_ref2 = this.parent) != null ? _ref2.children : void 0) != null ? _ref1 : (_ref3 = this.plugin) != null ? _ref3.topLevel : void 0) != null ? _ref[this.indexInParent() + 1] : void 0;
    };

    Group.prototype.contentsChanged = function(propagate, firstTime) {
      var _ref, _ref1;
      if (propagate == null) {
        propagate = true;
      }
      if (firstTime == null) {
        firstTime = false;
      }
      if ((_ref = this.type()) != null) {
        if (typeof _ref.contentsChanged === "function") {
          _ref.contentsChanged(this, firstTime);
        }
      }
      if (propagate) {
        return (_ref1 = this.parent) != null ? _ref1.contentsChanged(true) : void 0;
      }
    };

    Group.prototype.toJSON = function() {
      var attr, child, data, _i, _len, _ref, _ref1, _ref2;
      data = {};
      _ref = this.open.attributes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attr = _ref[_i];
        if (attr.nodeName.slice(0, 6) === 'data-' && attr.nodeName.slice(0, 10) !== 'data-mce-') {
          try {
            data[attr.nodeName] = JSON.parse(attr.nodeValue)[0];
          } catch (_error) {}
        }
      }
      return {
        id: this.id(),
        typeName: this.typeName(),
        deleted: this.deleted,
        text: this.contentAsText(),
        html: this.contentAsHTML(),
        parent: (_ref1 = (_ref2 = this.parent) != null ? _ref2.id() : void 0) != null ? _ref1 : null,
        children: (function() {
          var _j, _len1, _ref3, _ref4, _ref5, _results;
          _ref4 = (_ref3 = this.children) != null ? _ref3 : [];
          _results = [];
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            child = _ref4[_j];
            _results.push((_ref5 = child != null ? child.id() : void 0) != null ? _ref5 : null);
          }
          return _results;
        }).call(this),
        data: data
      };
    };

    Group.prototype.connect = function(toGroup, tag) {
      var connection, connstring, mustAdd, oldConnection, oldConnections, _i, _j, _len, _len1, _ref, _ref1;
      if (tag == null) {
        tag = '';
      }
      connection = [this.id(), toGroup.id(), "" + tag];
      connstring = "" + connection;
      oldConnections = (_ref = this.get('connections')) != null ? _ref : [];
      mustAdd = true;
      for (_i = 0, _len = oldConnections.length; _i < _len; _i++) {
        oldConnection = oldConnections[_i];
        if (("" + oldConnection) === connstring) {
          mustAdd = false;
          break;
        }
      }
      if (mustAdd) {
        this.set('connections', __slice.call(oldConnections).concat([connection]));
      }
      oldConnections = (_ref1 = toGroup.get('connections')) != null ? _ref1 : [];
      mustAdd = true;
      for (_j = 0, _len1 = oldConnections.length; _j < _len1; _j++) {
        oldConnection = oldConnections[_j];
        if (("" + oldConnection) === connstring) {
          mustAdd = false;
          break;
        }
      }
      if (mustAdd) {
        return toGroup.set('connections', __slice.call(oldConnections).concat([connection]));
      }
    };

    Group.prototype.disconnect = function(fromGroup, tag) {
      var c, matches;
      if (tag == null) {
        tag = '';
      }
      matches = (function(_this) {
        return function(array) {
          return array[0] === _this.id() && array[1] === fromGroup.id() && (tag === array[2] || (typeof tag.test === "function" ? tag.test(array[2]) : void 0));
        };
      })(this);
      this.set('connections', (function() {
        var _i, _len, _ref, _ref1, _results;
        _ref1 = (_ref = this.get('connections')) != null ? _ref : [];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          if (!matches(c)) {
            _results.push(c);
          }
        }
        return _results;
      }).call(this));
      return fromGroup.set('connections', (function() {
        var _i, _len, _ref, _ref1, _results;
        _ref1 = (_ref = fromGroup.get('connections')) != null ? _ref : [];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          if (!matches(c)) {
            _results.push(c);
          }
        }
        return _results;
      })());
    };

    Group.prototype.connectionsOut = function() {
      var c, id, _i, _len, _ref, _ref1, _results;
      id = this.id();
      _ref1 = (_ref = this.get('connections')) != null ? _ref : [];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        c = _ref1[_i];
        if (c[0] === id) {
          _results.push(c);
        }
      }
      return _results;
    };

    Group.prototype.connectionsIn = function() {
      var c, id, _i, _len, _ref, _ref1, _results;
      id = this.id();
      _ref1 = (_ref = this.get('connections')) != null ? _ref : [];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        c = _ref1[_i];
        if (c[1] === id) {
          _results.push(c);
        }
      }
      return _results;
    };

    Group.prototype.getScreenBoundaries = function() {
      var close, index, onSameLine, open, rect, rects, toArray, _i, _len, _ref;
      toArray = function(a) {
        var i, _i, _ref, _results;
        if (a != null) {
          _results = [];
          for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(a[i]);
          }
          return _results;
        } else {
          return [];
        }
      };
      rects = toArray(this.open.getClientRects()).concat(toArray((_ref = this.outerRange()) != null ? _ref.getClientRects() : void 0)).concat(toArray(this.close.getClientRects()));
      if (rects.length === 0) {
        return null;
      }
      open = rects[0];
      open = {
        top: open.top,
        left: open.left,
        right: open.right,
        bottom: open.bottom
      };
      close = rects[rects.length - 1];
      close = {
        top: close.top,
        left: close.left,
        right: close.right,
        bottom: close.bottom
      };
      onSameLine = true;
      for (index = _i = 0, _len = rects.length; _i < _len; index = ++_i) {
        rect = rects[index];
        open.top = Math.min(open.top, rect.top);
        close.bottom = Math.max(close.bottom, rect.bottom);
        if (rect.left < open.left) {
          onSameLine = false;
        }
        if (rect.top > open.bottom) {
          onSameLine = false;
        }
      }
      if (onSameLine) {
        close.top = open.top;
        open.bottom = close.bottom;
      }
      if ((open.top === open.bottom || close.top === close.bottom || open.left === open.right || close.left === close.right) && !($(this.open)).hasClass('hide')) {
        return null;
      }
      return {
        open: open,
        close: close
      };
    };

    return Group;

  })();

  window.Group = Group;

  Groups = (function() {
    var isScanning;

    function Groups(editor) {
      this.editor = editor;
      this.drawGroups = __bind(this.drawGroups, this);
      this.grouperIndexOfRangeEndpoint = __bind(this.grouperIndexOfRangeEndpoint, this);
      this.groupsTouchingRange = __bind(this.groupsTouchingRange, this);
      this.rangeChanged = __bind(this.rangeChanged, this);
      this.groupAboveSelection = __bind(this.groupAboveSelection, this);
      this.groupAboveCursor = __bind(this.groupAboveCursor, this);
      this.groupAboveNode = __bind(this.groupAboveNode, this);
      this.grouperToGroup = __bind(this.grouperToGroup, this);
      this.ids = __bind(this.ids, this);
      this.registerGroup = __bind(this.registerGroup, this);
      this.scanDocument = __bind(this.scanDocument, this);
      this.enableScanning = __bind(this.enableScanning, this);
      this.disableScanning = __bind(this.disableScanning, this);
      this.hideOrShowGroupers = __bind(this.hideOrShowGroupers, this);
      this.allGroupers = __bind(this.allGroupers, this);
      this.groupCurrentSelection = __bind(this.groupCurrentSelection, this);
      this.updateConnectionsMode = __bind(this.updateConnectionsMode, this);
      this.updateButtonsAndMenuItems = __bind(this.updateButtonsAndMenuItems, this);
      this.addGroupType = __bind(this.addGroupType, this);
      this.setUsedID = __bind(this.setUsedID, this);
      this.isIdFree = __bind(this.isIdFree, this);
      this.addFreeId = __bind(this.addFreeId, this);
      this.nextFreeId = __bind(this.nextFreeId, this);
      this.groupTypes = {};
      this.topLevel = [];
      this.freeIds = [0];
      this.editor.Overlay.addDrawHandler(this.drawGroups);
    }

    Groups.prototype.nextFreeId = function() {
      if (this.freeIds.length > 1) {
        return this.freeIds.shift();
      } else {
        return this.freeIds[0]++;
      }
    };

    Groups.prototype.addFreeId = function(id) {
      if (id < this.freeIds[this.freeIds.length - 1]) {
        this.freeIds.push(id);
        return this.freeIds.sort(function(a, b) {
          return a - b;
        });
      }
    };

    Groups.prototype.isIdFree = function(id) {
      return __indexOf.call(this.freeIds, id) >= 0 || id > this.freeIds[this.freeIds.length];
    };

    Groups.prototype.setUsedID = function(id) {
      var i, last;
      last = this.freeIds[this.freeIds.length - 1];
      while (last < id) {
        this.freeIds.push(++last);
      }
      i = this.freeIds.indexOf(id);
      this.freeIds.splice(i, 1);
      if (i === this.freeIds.length) {
        return this.freeIds.push(id + 1);
      }
    };

    Groups.prototype.addGroupType = function(name, data) {
      var blob, buttonData, key, menuData, n, plugin, _ref;
      if (data == null) {
        data = {};
      }
      name = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = name.length; _i < _len; _i++) {
          n = name[_i];
          if (/[a-zA-Z_-]/.test(n)) {
            _results.push(n);
          }
        }
        return _results;
      })()).join('');
      this.groupTypes[name] = data;
      if (data.hasOwnProperty('text')) {
        plugin = this;
        if (data.imageHTML != null) {
          data.image = htmlToImage(data.imageHTML);
        }
        if (data.openImageHTML != null) {
          blob = svgBlobForHTML(data.openImageHTML, createStyleString());
          data.openImage = objectURLForBlob(blob);
          base64URLForBlob(blob, function(result) {
            return data.openImage = result;
          });
        }
        if (data.closeImageHTML != null) {
          blob = svgBlobForHTML(data.closeImageHTML, createStyleString());
          data.closeImage = objectURLForBlob(blob);
          base64URLForBlob(blob, function(result) {
            return data.closeImage = result;
          });
        }
        menuData = {
          text: data.text,
          context: (_ref = data.context) != null ? _ref : 'Insert',
          onclick: (function(_this) {
            return function() {
              return _this.groupCurrentSelection(name);
            };
          })(this),
          onPostRender: function() {
            plugin.groupTypes[name].menuItem = this;
            return plugin.updateButtonsAndMenuItems();
          }
        };
        if (data.shortcut != null) {
          menuData.shortcut = data.shortcut;
        }
        if (data.icon != null) {
          menuData.icon = data.icon;
        }
        this.editor.addMenuItem(name, menuData);
        buttonData = {
          tooltip: data.tooltip,
          onclick: (function(_this) {
            return function() {
              return _this.groupCurrentSelection(name);
            };
          })(this),
          onPostRender: function() {
            plugin.groupTypes[name].button = this;
            return plugin.updateButtonsAndMenuItems();
          }
        };
        key = data.image != null ? 'image' : data.icon != null ? 'icon' : 'text';
        buttonData[key] = data[key];
        this.editor.addButton(name, buttonData);
      }
      return data.connections != null ? data.connections : data.connections = function(group) {
        var t, triples;
        triples = group.connectionsOut();
        return __slice.call(triples).concat(__slice.call((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = triples.length; _i < _len; _i++) {
              t = triples[_i];
              _results.push(t[1]);
            }
            return _results;
          })()));
      };
    };

    Groups.prototype.updateButtonsAndMenuItems = function() {
      var left, name, right, type, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      left = (_ref = this.editor) != null ? (_ref1 = _ref.selection) != null ? (_ref2 = _ref1.getRng()) != null ? _ref2.cloneRange() : void 0 : void 0 : void 0;
      if (!left) {
        return;
      }
      right = left.cloneRange();
      left.collapse(true);
      right.collapse(false);
      left = this.groupAboveCursor(left);
      right = this.groupAboveCursor(right);
      _ref3 = this.groupTypes;
      for (name in _ref3) {
        if (!__hasProp.call(_ref3, name)) continue;
        type = _ref3[name];
        if (type != null) {
          if ((_ref4 = type.button) != null) {
            _ref4.disabled(left !== right);
          }
        }
        if (type != null) {
          if ((_ref5 = type.menuItem) != null) {
            _ref5.disabled(left !== right);
          }
        }
      }
      if ((_ref6 = this.connectionsButton) != null) {
        _ref6.disabled((left == null) || (left !== right));
      }
      return this.updateConnectionsMode();
    };

    Groups.prototype.updateConnectionsMode = function() {
      var _ref, _ref1;
      if ((_ref = this.connectionsButton) != null ? _ref.disabled() : void 0) {
        return (_ref1 = this.connectionsButton) != null ? _ref1.active(false) : void 0;
      }
    };

    Groups.prototype.groupCurrentSelection = function(type) {
      var close, content, cursor, hide, id, leftNode, leftPos, newGroup, open, range, rightNode, rightPos, sel, _ref, _ref1, _ref2, _ref3, _ref4;
      if (!this.groupTypes.hasOwnProperty(type)) {
        return;
      }
      hide = ($((_ref = this.allGroupers()) != null ? _ref[0] : void 0)).hasClass('hide');
      id = this.nextFreeId();
      open = grouperHTML(type, 'open', id, hide, this.groupTypes[type].openImage);
      close = grouperHTML(type, 'close', id, hide, this.groupTypes[type].closeImage);
      sel = this.editor.selection;
      if (sel.getStart() === sel.getEnd()) {
        content = this.editor.selection.getContent();
        this.editor.insertContent(open + content + '{$caret}' + close);
        cursor = this.editor.selection.getRng();
        close = (_ref1 = cursor.endContainer.childNodes[cursor.endOffset]) != null ? _ref1 : cursor.endContainer.nextSibling;
        if (close.tagName === 'P') {
          close = close.childNodes[0];
        }
        newGroup = this.grouperToGroup(close);
        return (_ref2 = newGroup.parent) != null ? _ref2.contentsChanged() : void 0;
      } else {
        range = sel.getRng();
        leftNode = range.startContainer;
        leftPos = range.startOffset;
        rightNode = range.endContainer;
        rightPos = range.endOffset;
        range.collapse(false);
        sel.setRng(range);
        this.disableScanning();
        this.editor.insertContent('{$caret}' + close);
        range = sel.getRng();
        close = (_ref3 = range.endContainer.childNodes[range.endOffset]) != null ? _ref3 : range.endContainer.nextSibling;
        range.setStart(leftNode, leftPos);
        range.setEnd(leftNode, leftPos);
        sel.setRng(range);
        this.editor.insertContent(open);
        this.enableScanning();
        this.editor.selection.select(close);
        this.editor.selection.collapse(true);
        newGroup = this.grouperToGroup(close);
        return (_ref4 = newGroup.parent) != null ? _ref4.contentsChanged() : void 0;
      }
    };

    Groups.prototype.allGroupers = function() {
      return this.editor.getDoc().getElementsByClassName('grouper');
    };

    Groups.prototype.hideOrShowGroupers = function() {
      var groupers, _ref;
      groupers = $(this.allGroupers());
      if (($(groupers != null ? groupers[0] : void 0)).hasClass('hide')) {
        groupers.removeClass('hide');
      } else {
        groupers.addClass('hide');
      }
      groupers.filter('.decorate').each((function(_this) {
        return function(index, grouper) {
          return _this.grouperToGroup(grouper).updateGrouper(grouper);
        };
      })(this));
      if ((_ref = this.editor.Overlay) != null) {
        _ref.redrawContents();
      }
      return this.editor.focus();
    };

    Groups.prototype.disableScanning = function() {
      return this.scanLocks = (this.scanLocks != null ? this.scanLocks : this.scanLocks = 0) + 1;
    };

    Groups.prototype.enableScanning = function() {
      var _ref;
      this.scanLocks = Math.max(((_ref = this.scanLocks) != null ? _ref : 0) - 1, 0);
      if (this.scanLocks === 0) {
        return this.scanDocument();
      }
    };

    isScanning = false;

    Groups.prototype.scanDocument = function() {
      var a, after, becameFree, before, child, connection, count, deleted, gpStack, group, groupData, grouper, groupers, id, index, info, newGroup, newId, originalId, updateConnections, usedIds, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      if (this.scanLocks > 0) {
        return;
      }
      if (isScanning) {
        return setTimeout(((function(_this) {
          return function() {
            return _this.scanDocument;
          };
        })(this)), 0);
      }
      isScanning = true;
      _ref = this.ids();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        if (this[id] != null) {
          this[id].old = true;
        }
      }
      groupers = Array.prototype.slice.apply(this.allGroupers());
      gpStack = [];
      usedIds = [];
      this.topLevel = [];
      this.idConversionMap = {};
      before = this.freeIds.slice(0);
      index = function(id) {
        var gp, i, _j, _len1;
        for (i = _j = 0, _len1 = gpStack.length; _j < _len1; i = ++_j) {
          gp = gpStack[i];
          if (gp.id === id) {
            return i;
          }
        }
        return -1;
      };
      for (_j = 0, _len1 = groupers.length; _j < _len1; _j++) {
        grouper = groupers[_j];
        if ((info = grouperInfo(grouper)) == null) {
          ($(grouper)).remove();
        } else if (info.openOrClose === 'open') {
          gpStack.unshift({
            id: info.id,
            grouper: grouper,
            children: []
          });
        } else {
          if (index(info.id) === -1) {
            ($(grouper)).remove();
          } else {
            while (gpStack[0].id !== info.id) {
              ($(gpStack.shift().grouper)).remove();
            }
            groupData = gpStack.shift();
            id = this.registerGroup(groupData.grouper, grouper);
            usedIds.push(id);
            newGroup = this[id];
            newGroup.children = groupData.children;
            _ref1 = newGroup.children;
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              child = _ref1[_k];
              child.parent = newGroup;
            }
            if (gpStack.length > 0) {
              gpStack[0].children.push(newGroup);
            } else {
              this.topLevel.push(newGroup);
              newGroup.parent = null;
            }
          }
        }
      }
      while (gpStack.length > 0) {
        ($(gpStack.shift().grouper)).remove();
      }
      usedIds.sort(function(a, b) {
        return a - b;
      });
      count = 0;
      this.freeIds = [];
      while (usedIds.length > 0) {
        if (count === usedIds[0]) {
          while (count === usedIds[0]) {
            usedIds.shift();
          }
        } else {
          this.freeIds.push(count);
        }
        count++;
      }
      this.freeIds.push(count);
      after = this.freeIds.slice(0);
      while (before[before.length - 1] < after[after.length - 1]) {
        before.push(before[before.length - 1] + 1);
      }
      while (after[after.length - 1] < before[before.length - 1]) {
        after.push(after[after.length - 1] + 1);
      }
      becameFree = (function() {
        var _l, _len3, _results;
        _results = [];
        for (_l = 0, _len3 = after.length; _l < _len3; _l++) {
          a = after[_l];
          if (__indexOf.call(before, a) < 0) {
            _results.push(a);
          }
        }
        return _results;
      })();
      deleted = [];
      for (_l = 0, _len3 = becameFree.length; _l < _len3; _l++) {
        id = becameFree[_l];
        deleted.push(this[id]);
        if ((_ref2 = this[id]) != null) {
          _ref2.deleted = true;
        }
        delete this[id];
      }
      for (_m = 0, _len4 = deleted.length; _m < _len4; _m++) {
        group = deleted[_m];
        if (group != null) {
          if ((_ref3 = group.type()) != null) {
            if (typeof _ref3.deleted === "function") {
              _ref3.deleted(group);
            }
          }
        }
      }
      updateConnections = (function(_this) {
        return function(group, inOutBoth) {
          var connection, connections, _len5, _n;
          if (inOutBoth == null) {
            inOutBoth = 'both';
          }
          if (!(connections = group.get('connections'))) {
            return;
          }
          id = group.id();
          for (_n = 0, _len5 = connections.length; _n < _len5; _n++) {
            connection = connections[_n];
            if (inOutBoth === 'both' || (connection[0] === id && inOutBoth === 'out')) {
              if (_this.idConversionMap.hasOwnProperty(connection[1])) {
                connection[1] = _this.idConversionMap[connection[1]];
              }
            }
            if (inOutBoth === 'both' || (connection[1] === id && inOutBoth === 'in')) {
              if (_this.idConversionMap.hasOwnProperty(connection[0])) {
                connection[0] = _this.idConversionMap[connection[0]];
              }
            }
          }
          return group.set('connections', connections);
        };
      })(this);
      _ref4 = this.idConversionMap;
      for (originalId in _ref4) {
        if (!__hasProp.call(_ref4, originalId)) continue;
        newId = _ref4[originalId];
        updateConnections(this[newId]);
        _ref5 = newGroup.connectionsOut();
        for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
          connection = _ref5[_n];
          updateConnections(this[connection[1]], 'in');
        }
        _ref6 = newGroup.connectionsIn();
        for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
          connection = _ref6[_o];
          updateConnections(this[connection[0]], 'out');
        }
      }
      delete this.idsCache;
      setTimeout((function(_this) {
        return function() {
          var _ref7;
          if ((_ref7 = _this.editor.Overlay) != null) {
            _ref7.redrawContents();
          }
          return _this.updateButtonsAndMenuItems();
        };
      })(this), 0);
      return isScanning = false;
    };

    Groups.prototype.registerGroup = function(open, close) {
      var cached, doc, id, newId;
      cached = this[id = grouperInfo(open).id];
      if ((cached != null ? cached.open : void 0) !== open || (cached != null ? cached.close : void 0) !== close) {
        if ((this[id] != null) && !this[id].old) {
          newId = 0;
          doc = this.editor.getDoc();
          while (doc.getElementById(("open" + newId) || doc.getElementById("close" + newId))) {
            newId++;
          }
          open.setAttribute('id', "open" + newId);
          close.setAttribute('id', "close" + newId);
          this.idConversionMap[id] = newId;
          id = newId;
        }
        this[id] = new Group(open, close, this);
      } else {
        delete this[id].old;
      }
      if (open.naturalWidth === void 0 || open.naturalWidth === 0) {
        this[id].updateGrouper('open');
      }
      if (close.naturalWidth === void 0 || close.naturalWidth === 0) {
        this[id].updateGrouper('close');
      }
      return id;
    };

    Groups.prototype.ids = function() {
      var group, recur, _i, _len, _ref;
      if (this.idsCache == null) {
        this.idsCache = [];
        recur = (function(_this) {
          return function(g) {
            var child, _i, _len, _ref, _results;
            _this.idsCache.push(g.id());
            _ref = g.children;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              child = _ref[_i];
              _results.push(recur(child));
            }
            return _results;
          };
        })(this);
        _ref = this.topLevel;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          recur(group);
        }
      }
      return this.idsCache;
    };

    Groups.prototype.grouperToGroup = function(grouper) {
      var id, _ref;
      if ((id = (_ref = grouperInfo(grouper)) != null ? _ref.id : void 0) != null) {
        return this[id];
      } else {
        return null;
      }
    };

    Groups.prototype.groupAboveNode = function(node) {
      var all, group, left, middle, right;
      if ((all = this.allGroupers()).length === 0) {
        return null;
      }
      left = {
        index: 0,
        grouper: all[0],
        leftOfNode: true
      };
      if (left.grouper === node) {
        return this.grouperToGroup(left.grouper);
      }
      if (!strictNodeOrder(left.grouper, node)) {
        return null;
      }
      right = {
        index: all.length - 1,
        grouper: all[all.length - 1]
      };
      if (right.grouper === node) {
        return this.grouperToGroup(right.grouper);
      }
      if (strictNodeOrder(right.grouper, node)) {
        return null;
      }
      while (true) {
        if (left.grouper === node) {
          return this.grouperToGroup(left.grouper);
        }
        if (right.grouper === node) {
          return this.grouperToGroup(right.grouper);
        }
        if (left.index + 1 === right.index) {
          if (!(group = this.grouperToGroup(left.grouper))) {
            return null;
          }
          if (left.grouper === group.open) {
            return group;
          } else {
            return group.parent;
          }
        }
        middle = Math.floor((left.index + right.index) / 2);
        if (strictNodeOrder(all[middle], node)) {
          left = {
            index: middle,
            grouper: all[middle],
            leftOfNode: true
          };
        } else {
          right = {
            index: middle,
            grouper: all[middle],
            leftOfNode: false
          };
        }
      }
    };

    Groups.prototype.groupAboveCursor = function(cursor) {
      var elementAfter, elementBefore, itsGroup;
      if (cursor.startContainer instanceof this.editor.getWin().Text) {
        return this.groupAboveNode(cursor.startContainer);
      }
      if (cursor.startContainer.childNodes.length > cursor.startOffset) {
        elementAfter = cursor.startContainer.childNodes[cursor.startOffset];
        itsGroup = this.groupAboveNode(elementAfter);
        if ((itsGroup != null ? itsGroup.open : void 0) === elementAfter) {
          return itsGroup.parent;
        } else {
          return itsGroup;
        }
      }
      if (cursor.startContainer.childNodes.length > 0) {
        elementBefore = cursor.startContainer.childNodes[cursor.startOffset - 1];
        itsGroup = this.groupAboveNode(elementBefore);
        if ((itsGroup != null ? itsGroup.close : void 0) === elementBefore) {
          return itsGroup.parent;
        } else {
          return itsGroup;
        }
      }
      return this.groupAboveNode(cursor.startContainer);
    };

    Groups.prototype.groupAboveSelection = function(range) {
      var left, leftChain, result, right, rightChain;
      left = range.cloneRange();
      left.collapse(true);
      left = this.groupAboveCursor(left);
      leftChain = [];
      while (left != null) {
        leftChain.unshift(left);
        left = left.parent;
      }
      right = range.cloneRange();
      right.collapse(false);
      right = this.groupAboveCursor(right);
      rightChain = [];
      while (right != null) {
        rightChain.unshift(right);
        right = right.parent;
      }
      result = null;
      while (leftChain.length > 0 && rightChain.length > 0 && leftChain[0] === rightChain[0]) {
        result = leftChain.shift();
        rightChain.shift();
      }
      return result;
    };

    Groups.prototype.rangeChanged = function(range) {
      var group, _i, _len, _ref, _results;
      _ref = this.groupsTouchingRange(range);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        group = _ref[_i];
        _results.push(group.contentsChanged(false));
      }
      return _results;
    };

    Groups.prototype.groupsTouchingRange = function(range) {
      var all, firstInRange, group, index, lastInRange, maybeOneMore, node, result, stack, _i, _ref;
      if ((all = this.allGroupers()).length === 0) {
        return [];
      }
      firstInRange = 1 + this.grouperIndexOfRangeEndpoint(range, true, all);
      lastInRange = this.grouperIndexOfRangeEndpoint(range, false, all);
      if (firstInRange > lastInRange) {
        node = range.startContainer;
        if (node instanceof this.editor.getWin().Element && range.startOffset < node.childNodes.length) {
          node = node.childNodes[range.startOffset];
        }
        group = this.groupAboveNode(node);
        result = group ? group.open === node ? group.parent ? [group.parent] : [] : [group] : [];
        while (maybeOneMore = (_ref = result[result.length - 1]) != null ? _ref.parent : void 0) {
          result.push(maybeOneMore);
        }
        return result;
      }
      stack = [];
      result = [];
      for (index = _i = firstInRange; firstInRange <= lastInRange ? _i <= lastInRange : _i >= lastInRange; index = firstInRange <= lastInRange ? ++_i : --_i) {
        group = this.grouperToGroup(all[index]);
        if (all[index] === group.open) {
          stack.push(group);
        } else {
          result.push(group);
          stack.pop();
        }
      }
      while (stack.length > 0) {
        result.push(stack.pop());
      }
      while (maybeOneMore = result[result.length - 1].parent) {
        result.push(maybeOneMore);
      }
      return result;
    };

    Groups.prototype.grouperIndexOfRangeEndpoint = function(range, left, all) {
      var endpoint, isLeftOfEndpoint, middle, right;
      if ((all != null ? all : all = this.allGroupers()).length === 0) {
        return -1;
      }
      endpoint = left ? Range.END_TO_START : Range.END_TO_END;
      isLeftOfEndpoint = (function(_this) {
        return function(grouper) {
          var grouperRange;
          grouperRange = _this.editor.getDoc().createRange();
          grouperRange.selectNode(grouper);
          return range.compareBoundaryPoints(endpoint, grouperRange) > -1;
        };
      })(this);
      left = 0;
      if (!isLeftOfEndpoint(all[left])) {
        return -1;
      }
      right = all.length - 1;
      if (isLeftOfEndpoint(all[right])) {
        return right;
      }
      while (true) {
        if (left + 1 === right) {
          return left;
        }
        middle = Math.floor((left + right) / 2);
        if (isLeftOfEndpoint(all[middle])) {
          left = middle;
        } else {
          right = middle;
        }
      }
    };

    Groups.prototype.drawGroups = function(canvas, context) {
      var bodyStyle, bottomEdge, c, connection, connections, drawArrow, drawGroup, gap, group, groupEdgesToConnect, index, innermost, interp, leftMar, moveBy, numArrays, old, pad, padStep, radius, rightMar, size, tag, tags, tagsToDraw, topEdge, walk, x1, x2, y1, y2, _base, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _results;
      this.bubbleTags = [];
      if (this.scanLocks > 0) {
        return;
      }
      group = this.groupAboveSelection(this.editor.selection.getRng());
      bodyStyle = getComputedStyle(this.editor.getBody());
      leftMar = parseInt(bodyStyle['margin-left']);
      rightMar = parseInt(bodyStyle['margin-right']);
      pad = 3;
      padStep = 2;
      radius = 4;
      tags = [];
      drawGroup = (function(_this) {
        return function(group, drawOutline, drawInterior, withTag) {
          var boundaries, close, color, open, tagString, type, x1, x2, y1, y2, _ref;
          type = group.type();
          color = (_ref = type != null ? type.color : void 0) != null ? _ref : '#444444';
          if (!(boundaries = group.getScreenBoundaries())) {
            setTimeout((function() {
              var _ref1;
              return (_ref1 = _this.editor.Overlay) != null ? _ref1.redrawContents() : void 0;
            }), 100);
            return null;
          }
          open = boundaries.open, close = boundaries.close;
          x1 = open.left - pad / 3;
          y1 = open.top - pad;
          x2 = close.right + pad / 3;
          y2 = close.bottom + pad;
          if (withTag && (tagString = type != null ? typeof type.tagContents === "function" ? type.tagContents(group) : void 0 : void 0)) {
            tags.push({
              content: tagString,
              corner: {
                x: x1,
                y: y1
              },
              color: color,
              style: createFontStyleString(group.open),
              group: group
            });
          }
          context.fillStyle = context.strokeStyle = color;
          if (open.top === close.top && open.bottom === close.bottom) {
            context.roundedRect(x1, y1, x2, y2, radius);
          } else {
            context.roundedZone(x1, y1, x2, y2, open.bottom, close.top, leftMar, rightMar, radius);
          }
          if (drawOutline) {
            context.globalAlpha = 1.0;
            context.lineWidth = 1.5;
            context.stroke();
          }
          if (drawInterior) {
            context.globalAlpha = 0.3;
            context.fill();
          }
          return true;
        };
      })(this);
      innermost = true;
      walk = group;
      while (walk) {
        if (!drawGroup(walk, true, innermost, true)) {
          return;
        }
        walk = walk.parent;
        pad += padStep;
        innermost = false;
      }
      tagsToDraw = [];
      while (tags.length > 0) {
        tag = tags.shift();
        context.font = tag.font;
        if (!(size = context.measureHTML(tag.content, tag.style))) {
          setTimeout(((function(_this) {
            return function() {
              var _ref;
              return (_ref = _this.editor.Overlay) != null ? _ref.redrawContents() : void 0;
            };
          })(this)), 10);
          return;
        }
        x1 = tag.corner.x - padStep;
        y1 = tag.corner.y - size.height - 2 * padStep;
        x2 = x1 + 2 * padStep + size.width;
        y2 = tag.corner.y;
        for (_i = 0, _len = tagsToDraw.length; _i < _len; _i++) {
          old = tagsToDraw[_i];
          if (rectanglesCollide(x1, y1, x2, y2, old.x1, old.y1, old.x2, old.y2)) {
            moveBy = old.y1 - y2;
            y1 += moveBy;
            y2 += moveBy;
          }
        }
        y2 = tag.corner.y;
        _ref = [x1, y1, x2, y2], tag.x1 = _ref[0], tag.y1 = _ref[1], tag.x2 = _ref[2], tag.y2 = _ref[3];
        tagsToDraw.unshift(tag);
      }
      for (_j = 0, _len1 = tagsToDraw.length; _j < _len1; _j++) {
        tag = tagsToDraw[_j];
        context.roundedRect(tag.x1, tag.y1, tag.x2, tag.y2, radius);
        context.globalAlpha = 1.0;
        context.fillStyle = '#ffffff';
        context.fill();
        context.lineWidth = 1.5;
        context.strokeStyle = tag.color;
        context.stroke();
        context.globalAlpha = 0.7;
        context.fillStyle = tag.color;
        context.fill();
        context.fillStyle = '#000000';
        context.globalAlpha = 1.0;
        if (!context.drawHTML(tag.content, tag.x1 + padStep, tag.y1, tag.style)) {
          setTimeout(((function(_this) {
            return function() {
              var _ref1;
              return (_ref1 = _this.editor.Overlay) != null ? _ref1.redrawContents() : void 0;
            };
          })(this)), 10);
          return;
        }
        this.bubbleTags.unshift(tag);
      }
      pad = 3;
      if (this.groupUnderMouse) {
        if (!drawGroup(this.groupUnderMouse, false, true, false)) {
          return;
        }
      }
      topEdge = (function(_this) {
        return function(open, close) {
          return {
            left: {
              x: open.left,
              y: open.top
            },
            right: {
              x: open.top === close.top && open.bottom === close.bottom ? close.right : canvas.width - rightMar,
              y: open.top
            }
          };
        };
      })(this);
      bottomEdge = (function(_this) {
        return function(open, close) {
          return {
            left: {
              x: open.top === close.top && open.bottom === close.bottom ? open.left : leftMar,
              y: close.bottom
            },
            right: {
              x: close.right,
              y: close.bottom
            }
          };
        };
      })(this);
      gap = 20;
      groupEdgesToConnect = (function(_this) {
        return function(fromBds, toBds) {
          if (fromBds.close.bottom + gap < toBds.open.top) {
            return {
              from: bottomEdge(fromBds.open, fromBds.close),
              to: topEdge(toBds.open, toBds.close),
              startDir: 1,
              endDir: 1
            };
          } else if (toBds.close.bottom + gap < fromBds.open.top) {
            return {
              from: topEdge(fromBds.open, fromBds.close),
              to: bottomEdge(toBds.open, toBds.close),
              startDir: -1,
              endDir: -1
            };
          } else {
            return {
              from: topEdge(fromBds.open, fromBds.close),
              to: topEdge(toBds.open, toBds.close),
              startDir: -1,
              endDir: 1
            };
          }
        };
      })(this);
      interp = (function(_this) {
        return function(left, right, index, length) {
          var pct;
          pct = (index + 1) / (length + 1);
          right = Math.min(right, left + 40 * length);
          return (1 - pct) * left + pct * right;
        };
      })(this);
      drawArrow = (function(_this) {
        return function(index, outOf, from, to, label, setStyle) {
          var centerX, centerY, endX, endY, fromBox, how, startX, startY, style, toBox, _ref1, _ref2, _ref3;
          context.save();
          context.strokeStyle = ((_ref1 = from.type()) != null ? _ref1.color : void 0) || '#444444';
          if (typeof setStyle === "function") {
            setStyle(context);
          }
          context.globalAlpha = 1.0;
          context.lineWidth = 2;
          fromBox = from.getScreenBoundaries();
          toBox = to.getScreenBoundaries();
          if (!fromBox || !toBox) {
            return;
          }
          fromBox.open.top -= pad;
          fromBox.close.top -= pad;
          fromBox.open.bottom += pad;
          fromBox.close.bottom += pad;
          toBox.open.top -= pad;
          toBox.close.top -= pad;
          toBox.open.bottom += pad;
          toBox.close.bottom += pad;
          how = groupEdgesToConnect(fromBox, toBox);
          startX = interp(how.from.left.x, how.from.right.x, index, outOf);
          startY = how.from.left.y;
          endX = interp(how.to.left.x, how.to.right.x, index, outOf);
          endY = how.to.left.y;
          context.bezierArrow(startX, startY, startX, startY + how.startDir * gap, endX, endY - how.endDir * gap, endX, endY);
          context.stroke();
          if (label !== '') {
            centerX = context.applyBezier(startX, startX, endX, endX, 0.5);
            centerY = context.applyBezier(startY, startY + how.startDir * gap, endY - how.endDir * gap, endY, 0.5);
            style = createFontStyleString(group.open);
            if (!(size = context.measureHTML(label, style))) {
              setTimeout((function() {
                var _ref2;
                return (_ref2 = _this.editor.Overlay) != null ? _ref2.redrawContents() : void 0;
              }), 10);
              return;
            }
            context.roundedRect(centerX - size.width / 2 - padStep, centerY - size.height / 2 - padStep, centerX + size.width / 2 + padStep, centerY + size.width / 2, radius);
            context.globalAlpha = 1.0;
            context.fillStyle = '#ffffff';
            context.fill();
            context.lineWidth = 1.5;
            context.strokeStyle = (_ref2 = (_ref3 = from.type()) != null ? _ref3.color : void 0) != null ? _ref2 : '#444444';
            context.stroke();
            context.fillStyle = '#000000';
            context.globalAlpha = 1.0;
            context.drawHTML(label, centerX - size.width / 2 + padStep, centerY - size.height / 2, style);
          }
          return context.restore();
        };
      })(this);
      if (group) {
        connections = typeof (_base = group.type()).connections === "function" ? _base.connections(group) : void 0;
        numArrays = ((function() {
          var _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = connections.length; _k < _len2; _k++) {
            c = connections[_k];
            if (c instanceof Array) {
              _results.push(c);
            }
          }
          return _results;
        })()).length;
        _ref1 = connections != null ? connections : [];
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          connection = _ref1[_k];
          if (!(connection instanceof Array)) {
            drawGroup(this[connection], true, false, false);
          }
        }
        _ref2 = connections != null ? connections : [];
        _results = [];
        for (index = _l = 0, _len3 = _ref2.length; _l < _len3; index = ++_l) {
          connection = _ref2[index];
          if (connection instanceof Array) {
            _results.push(drawArrow.apply(null, [index, numArrays, this[connection[0]], this[connection[1]]].concat(__slice.call(connection.slice(2)))));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    return Groups;

  })();

  tinymce.PluginManager.add('groups', function(editor, url) {
    var type, _i, _len, _ref;
    editor.Groups = new Groups(editor);
    editor.on('init', function(event) {
      return editor.dom.loadCSS('groupsplugin.css');
    });
    _ref = editor.settings.groupTypes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      type = _ref[_i];
      editor.Groups.addGroupType(type.name, type);
    }
    editor.addMenuItem('hideshowgroups', {
      text: 'Hide/show groups',
      context: 'View',
      onclick: function() {
        return editor.Groups.hideOrShowGroupers();
      }
    });
    if (window.useGroupConnectionsUI) {
      editor.addButton('connect', {
        image: htmlToImage('&#x2197;'),
        tooltip: 'Connect groups',
        onclick: function() {
          this.active(!this.active());
          return editor.Groups.updateConnectionsMode();
        },
        onPostRender: function() {
          editor.Groups.connectionsButton = this;
          return editor.Groups.updateButtonsAndMenuItems();
        }
      });
    }
    editor.on('change SetContent', function(event) {
      var orig, range, _ref1;
      editor.Groups.scanDocument();
      if (event != null ? (_ref1 = event.level) != null ? _ref1.bookmark : void 0 : void 0) {
        orig = editor.selection.getBookmark();
        editor.selection.moveToBookmark(event.level.bookmark);
        range = editor.selection.getRng();
        editor.selection.moveToBookmark(orig);
        return editor.Groups.rangeChanged(range);
      }
    });
    editor.on('KeyUp', function(event) {
      var modifiers, movements, _ref1, _ref2;
      movements = [33, 34, 35, 36, 37, 38, 39, 40];
      modifiers = [16, 17, 18, 91];
      if ((_ref1 = event.keyCode, __indexOf.call(movements, _ref1) >= 0) || (_ref2 = event.keyCode, __indexOf.call(modifiers, _ref2) >= 0)) {
        return;
      }
      editor.Groups.scanDocument();
      return editor.Groups.rangeChanged(editor.selection.getRng());
    });
    editor.on('NodeChange', function(event) {
      return editor.Groups.updateButtonsAndMenuItems();
    });
    editor.on('contextMenu', function(event) {
      var contextmenu, group, item, items, menu, name, newItems, node, pos, x, y, _j, _len1, _ref1, _ref2;
      event.preventDefault();
      x = event.clientX;
      y = event.clientY;
      if (node = editor.getDoc().nodeFromPoint(x, y)) {
        group = editor.Groups.groupAboveNode(node);
      }
      contextmenu = editor.settings.contextmenu || 'link image inserttable | cell row column deletetable';
      items = [];
      _ref1 = contextmenu.split(/[ ,]/);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        name = _ref1[_j];
        item = editor.menuItems[name];
        if (name === '|') {
          item = {
            text: name
          };
        }
        if (item) {
          item.shortcut = '';
          items.push(item);
        }
      }
      if (newItems = group != null ? (_ref2 = group.type()) != null ? _ref2.contextMenuItems(group) : void 0 : void 0) {
        items.push({
          text: '|'
        });
        items = items.concat(newItems);
      }
      menu = new tinymce.ui.Menu({
        items: items,
        context: 'contextmenu',
        classes: 'contextmenu'
      }).renderTo();
      editor.on('remove', function() {
        menu.remove();
        return menu = null;
      });
      pos = ($(editor.getContentAreaContainer())).position();
      return menu.moveTo(x + pos.left, y + pos.top);
    });
    editor.on('mousedown', function(event) {
      var currentGroup, doc, el, group, info, left, menu, menuItems, pos, tag, x, y, _j, _len1, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      x = event.clientX;
      y = event.clientY;
      if ((_ref1 = editor.Groups.connectionsButton) != null ? _ref1.active() : void 0) {
        if (group = editor.groupUnderMouse(x, y)) {
          left = (_ref2 = editor.selection) != null ? (_ref3 = _ref2.getRng()) != null ? _ref3.cloneRange() : void 0 : void 0;
          if (!left) {
            return;
          }
          left.collapse(true);
          currentGroup = editor.Groups.groupAboveCursor(left);
          if ((_ref4 = currentGroup.type()) != null) {
            if (typeof _ref4.connectionRequest === "function") {
              _ref4.connectionRequest(currentGroup, group);
            }
          }
          event.preventDefault();
          if ((_ref5 = editor.Groups.connectionsButton) != null) {
            _ref5.active(false);
          }
          editor.Groups.updateConnectionsMode();
          return false;
        }
        return;
      }
      doc = editor.getDoc();
      el = doc.elementFromPoint(x, y);
      if (el && (info = grouperInfo(el))) {
        group = editor.Groups.grouperToGroup(el);
        if ((_ref6 = group.type()) != null) {
          if (typeof _ref6.clicked === "function") {
            _ref6.clicked(group, 'single', el === group.open ? 'open' : 'close');
          }
        }
        return false;
      }
      _ref7 = editor.Groups.bubbleTags;
      for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
        tag = _ref7[_j];
        if ((tag.x1 < x && x < tag.x2) && (tag.y1 < y && y < tag.y2)) {
          menuItems = (_ref8 = tag.group) != null ? (_ref9 = _ref8.type()) != null ? _ref9.tagMenuItems(tag.group) : void 0 : void 0;
          if (menuItems == null) {
            menuItems = [
              {
                text: 'no actions available',
                disabled: true
              }
            ];
          }
          menu = new tinymce.ui.Menu({
            items: menuItems,
            context: 'contextmenu',
            classes: 'contextmenu'
          }).renderTo();
          editor.on('remove', function() {
            menu.remove();
            return menu = null;
          });
          pos = ($(editor.getContentAreaContainer())).position();
          menu.moveTo(x + pos.left, y + pos.top);
          event.preventDefault();
          return false;
        }
      }
    });
    editor.on('dblclick', function(event) {
      var doc, el, group, info, _ref1;
      doc = editor.getDoc();
      el = doc.elementFromPoint(event.clientX, event.clientY);
      if (el && (info = grouperInfo(el))) {
        group = editor.Groups.grouperToGroup(el);
        if ((_ref1 = group.type()) != null) {
          if (typeof _ref1.clicked === "function") {
            _ref1.clicked(group, 'double', el === group.open ? 'open' : 'close');
          }
        }
        return false;
      }
    });
    editor.on('mousemove', function(event) {
      var _ref1;
      editor.Groups.groupUnderMouse = editor.groupUnderMouse(event.clientX, event.clientY);
      return (_ref1 = editor.Overlay) != null ? _ref1.redrawContents() : void 0;
    });
    editor.groupUnderMouse = function(x, y) {
      var doc, el, i, node, range, rect, rects, _j, _k, _len1, _ref1;
      doc = editor.getDoc();
      el = doc.elementFromPoint(x, y);
      for (i = _j = 0, _ref1 = el.childNodes.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        node = el.childNodes[i];
        if (node.nodeType === 3) {
          range = doc.createRange();
          range.selectNode(node);
          rects = range.getClientRects();
          rects = (function() {
            var _k, _ref2, _results;
            _results = [];
            for (i = _k = 0, _ref2 = rects.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
              _results.push(rects[i]);
            }
            return _results;
          })();
          for (_k = 0, _len1 = rects.length; _k < _len1; _k++) {
            rect = rects[_k];
            if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {
              return editor.Groups.groupAboveNode(node);
            }
          }
        }
      }
      return null;
    };
    return editor.on('KeyUp', function(event) {
      var allAfter, allBefore, allText, lastCharacter, modifiers, movements, newCursorPos, range, shortcut, typeData, typeName, _ref1, _ref2, _ref3, _results;
      movements = [33, 34, 35, 36, 37, 38, 39, 40];
      modifiers = [16, 17, 18, 91];
      if ((_ref1 = event.keyCode, __indexOf.call(movements, _ref1) >= 0) || (_ref2 = event.keyCode, __indexOf.call(modifiers, _ref2) >= 0)) {
        return;
      }
      range = editor.selection.getRng();
      if (range.startContainer === range.endContainer && range.startContainer instanceof editor.getWin().Text) {
        allText = range.startContainer.textContent;
        lastCharacter = allText[range.startOffset - 1];
        if (lastCharacter !== ' ' && lastCharacter !== '\\' && lastCharacter !== String.fromCharCode(160)) {
          return;
        }
        allBefore = allText.substr(0, range.startOffset - 1);
        allAfter = allText.substring(range.startOffset - 1);
        _ref3 = editor.Groups.groupTypes;
        _results = [];
        for (typeName in _ref3) {
          typeData = _ref3[typeName];
          if (shortcut = typeData.LaTeXshortcut) {
            if (allBefore.slice(-shortcut.length) === shortcut) {
              newCursorPos = range.startOffset - shortcut.length - 1;
              if (lastCharacter !== '\\') {
                allAfter = allAfter.substr(1);
              }
              allBefore = allBefore.slice(0, -shortcut.length);
              range.startContainer.textContent = allBefore + allAfter;
              range.setStart(range.startContainer, newCursorPos);
              if (lastCharacter === '\\') {
                range.setEnd(range.startContainer, newCursorPos + 1);
              } else {
                range.setEnd(range.startContainer, newCursorPos);
              }
              editor.selection.setRng(range);
              editor.Groups.groupCurrentSelection(typeName);
              break;
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    });
  });

  LoadSave = (function() {
    LoadSave.prototype.appName = null;

    LoadSave.setAppName = function(newname) {
      var instance, _i, _len, _ref, _results;
      if (newname == null) {
        newname = null;
      }
      LoadSave.prototype.appName = newname;
      _ref = LoadSave.prototype.instances;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        instance = _ref[_i];
        _results.push(instance.setAppName(newname));
      }
      return _results;
    };

    LoadSave.prototype.instances = [];

    function LoadSave(editor) {
      var control;
      this.editor = editor;
      this.manageFiles = __bind(this.manageFiles, this);
      this.handleOpen = __bind(this.handleOpen, this);
      this.tryToOpen = __bind(this.tryToOpen, this);
      this.load = __bind(this.load, this);
      this.tryToSave = __bind(this.tryToSave, this);
      this.save = __bind(this.save, this);
      this.tryToClear = __bind(this.tryToClear, this);
      this.clear = __bind(this.clear, this);
      this.setFileSystem = __bind(this.setFileSystem, this);
      this.setAppName = __bind(this.setAppName, this);
      this.setFilepath = __bind(this.setFilepath, this);
      this.setFilename = __bind(this.setFilename, this);
      this.setDocumentDirty = __bind(this.setDocumentDirty, this);
      this.recomputePageTitle = __bind(this.recomputePageTitle, this);
      this.setAppName(LoadSave.prototype.appName);
      this.setFileSystem(this.appName);
      this.setFilepath(FileSystem.prototype.pathSeparator);
      setTimeout(((function(_this) {
        return function() {
          return _this.clear();
        };
      })(this)), 0);
      this.saveMetaData = this.loadMetaData = null;
      this.editor.on('change', (function(_this) {
        return function(event) {
          return _this.setDocumentDirty(true);
        };
      })(this));
      control = (function(_this) {
        return function(name, data) {
          var buttonData, key;
          buttonData = {
            icon: data.icon,
            shortcut: data.shortcut,
            onclick: data.onclick,
            tooltip: data.tooltip
          };
          key = data.icon != null ? 'icon' : 'text';
          buttonData[key] = data[key];
          _this.editor.addButton(name, buttonData);
          return _this.editor.addMenuItem(name, data);
        };
      })(this);
      control('newfile', {
        text: 'New',
        icon: 'newdocument',
        context: 'file',
        shortcut: 'ctrl+N',
        tooltip: 'New file',
        onclick: (function(_this) {
          return function() {
            return _this.tryToClear();
          };
        })(this)
      });
      control('savefile', {
        text: 'Save',
        icon: 'save',
        context: 'file',
        shortcut: 'ctrl+S',
        tooltip: 'Save file',
        onclick: (function(_this) {
          return function() {
            return _this.tryToSave();
          };
        })(this)
      });
      this.editor.addMenuItem('saveas', {
        text: 'Save as...',
        context: 'file',
        shortcut: 'ctrl+shift+S',
        onclick: (function(_this) {
          return function() {
            return _this.tryToSave(null, '');
          };
        })(this)
      });
      control('openfile', {
        text: 'Open...',
        icon: 'browse',
        context: 'file',
        shortcut: 'ctrl+O',
        tooltip: 'Open file...',
        onclick: (function(_this) {
          return function() {
            return _this.handleOpen();
          };
        })(this)
      });
      this.editor.addMenuItem('managefiles', {
        text: 'Manage files...',
        context: 'file',
        onclick: (function(_this) {
          return function() {
            return _this.manageFiles();
          };
        })(this)
      });
      LoadSave.prototype.instances.push(this);
    }

    LoadSave.prototype.recomputePageTitle = function() {
      return document.title = "" + (this.appName ? this.appName + ': ' : '') + " " + (this.filename || '(untitled)') + " " + (this.documentDirty ? '*' : '');
    };

    LoadSave.prototype.setDocumentDirty = function(setting) {
      if (setting == null) {
        setting = true;
      }
      this.documentDirty = setting;
      return this.recomputePageTitle();
    };

    LoadSave.prototype.setFilename = function(newname) {
      if (newname == null) {
        newname = null;
      }
      this.filename = newname;
      return this.recomputePageTitle();
    };

    LoadSave.prototype.setFilepath = function(newpath) {
      if (newpath == null) {
        newpath = null;
      }
      return this.filepath = newpath;
    };

    LoadSave.prototype.setAppName = function(newname) {
      var mustAlsoUpdateFileSystem;
      if (newname == null) {
        newname = null;
      }
      mustAlsoUpdateFileSystem = this.appName === this.fileSystem;
      this.appName = newname;
      if (mustAlsoUpdateFileSystem) {
        this.fileSystem = this.appName;
      }
      return this.recomputePageTitle();
    };

    LoadSave.prototype.setFileSystem = function(newname) {
      if (newname == null) {
        newname = this.appName;
      }
      return this.fileSystem = newname;
    };

    LoadSave.prototype.clear = function() {
      this.editor.setContent('');
      this.setDocumentDirty(false);
      this.setFilename(null);
      return typeof this.loadMetaData === "function" ? this.loadMetaData({}) : void 0;
    };

    LoadSave.prototype.tryToClear = function() {
      if (!this.documentDirty) {
        this.clear();
        this.editor.focus();
        return;
      }
      return this.editor.windowManager.open({
        title: 'Save first?',
        buttons: [
          {
            text: 'Save',
            onclick: (function(_this) {
              return function() {
                _this.tryToSave(function(success) {
                  if (success) {
                    return _this.clear();
                  }
                });
                return _this.editor.windowManager.close();
              };
            })(this)
          }, {
            text: 'Discard',
            onclick: (function(_this) {
              return function() {
                _this.clear();
                return _this.editor.windowManager.close();
              };
            })(this)
          }, {
            text: 'Cancel',
            onclick: (function(_this) {
              return function() {
                return _this.editor.windowManager.close();
              };
            })(this)
          }
        ]
      });
    };

    LoadSave.prototype.save = function() {
      var objectToSave, tmp;
      if (this.filename === null) {
        return;
      }
      tmp = new FileSystem(this.fileSystem);
      tmp.cd(this.filepath);
      objectToSave = [this.editor.getContent(), typeof this.saveMetaData === "function" ? this.saveMetaData() : void 0];
      if (tmp.write(this.filename, objectToSave, true)) {
        return this.setDocumentDirty(false);
      }
    };

    LoadSave.prototype.tryToSave = function(callback, filename) {
      var filepath, refreshDialog, result, saveWouldOverwrite;
      if (filename == null) {
        filename = this.filename;
      }
      if (filename) {
        this.setFilename(filename);
        result = this.save();
        this.editor.focus();
        return typeof callback === "function" ? callback(result) : void 0;
      }
      refreshDialog = function() {
        var button, dialog, _i, _len, _ref, _results;
        dialog = document.getElementsByClassName('mce-window')[0];
        if (!dialog) {
          return;
        }
        _ref = dialog.getElementsByTagName('button');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          button = _ref[_i];
          if (button.textContent === 'Save') {
            if (filename) {
              button.removeAttribute('disabled');
              button.parentNode.style.backgroundImage = null;
              button.parentNode.style.backgroundColor = null;
            } else {
              button.setAttribute('disabled', true);
              button.parentNode.style.backgroundImage = 'none';
              button.parentNode.style.backgroundColor = '#ccc';
            }
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      filename = null;
      this.saveFileNameChangedHandler = function(newname) {
        filename = newname;
        return refreshDialog();
      };
      filepath = null;
      this.changedFolderHandler = function(newfolder) {
        return filepath = newfolder;
      };
      saveWouldOverwrite = (function(_this) {
        return function(filepath, filename) {
          var tmp;
          tmp = new FileSystem(_this.fileSystem);
          tmp.cd(filepath);
          return null !== tmp.type(filename);
        };
      })(this);
      this.buttonClickedHandler = (function(_this) {
        return function() {
          var args, name;
          name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (name === 'Save') {
            if (saveWouldOverwrite(filepath, filename)) {
              if (!confirm("Are you sure you want to overwrite the file " + filename + "?")) {
                _this.tellDialog('setFileBrowserMode', 'save file');
                return;
              }
            }
            _this.setFilepath(filepath);
            _this.setFilename(filename);
            _this.editor.windowManager.close();
            result = _this.save();
            return typeof callback === "function" ? callback(result) : void 0;
          } else if (name === 'Cancel') {
            _this.editor.windowManager.close();
            return typeof callback === "function" ? callback(false) : void 0;
          }
        };
      })(this);
      return this.editor.windowManager.open({
        title: 'Save file...',
        url: 'filedialog/filedialog.html',
        width: 600,
        height: 400,
        buttons: [
          {
            text: 'Save',
            subtype: 'primary',
            onclick: (function(_this) {
              return function() {
                return _this.buttonClickedHandler('Save');
              };
            })(this)
          }, {
            text: 'Cancel',
            onclick: (function(_this) {
              return function() {
                return _this.buttonClickedHandler('Cancel');
              };
            })(this)
          }
        ]
      }, {
        fsName: this.fileSystem,
        mode: 'save file'
      });
    };

    LoadSave.prototype.load = function(filepath, filename) {
      var content, metadata, tmp, _ref;
      if (filename === null) {
        return;
      }
      if (filepath === null) {
        filepath = '.';
      }
      tmp = new FileSystem(this.fileSystem);
      tmp.cd(filepath);
      _ref = tmp.read(filename), content = _ref[0], metadata = _ref[1];
      this.editor.setContent(content);
      this.editor.focus();
      this.setFilepath(filepath);
      this.setFilename(filename);
      this.setDocumentDirty(false);
      return typeof this.loadMetaData === "function" ? this.loadMetaData(metadata != null ? metadata : {}) : void 0;
    };

    LoadSave.prototype.tryToOpen = function(callback) {
      var filename, filepath, refreshDialog;
      if (callback == null) {
        callback = (function(_this) {
          return function(p, f) {
            return _this.load(p, f);
          };
        })(this);
      }
      refreshDialog = (function(_this) {
        return function() {
          var button, dialog, _i, _len, _ref, _results;
          dialog = document.getElementsByClassName('mce-window')[0];
          if (!dialog) {
            return;
          }
          _ref = dialog.getElementsByTagName('button');
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            button = _ref[_i];
            if (button.textContent === 'Open') {
              if (filename) {
                button.removeAttribute('disabled');
                button.parentNode.style.backgroundImage = null;
                button.parentNode.style.backgroundColor = null;
              } else {
                button.setAttribute('disabled', true);
                button.parentNode.style.backgroundImage = 'none';
                button.parentNode.style.backgroundColor = '#ccc';
              }
              break;
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
      })(this);
      filename = null;
      this.selectedFileHandler = function(newname) {
        filename = newname;
        return refreshDialog();
      };
      filepath = null;
      this.changedFolderHandler = function(newfolder) {
        return filepath = newfolder;
      };
      this.buttonClickedHandler = (function(_this) {
        return function() {
          var args, name;
          name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (name === 'Open') {
            _this.editor.windowManager.close();
            return typeof callback === "function" ? callback(filepath, filename) : void 0;
          } else if (name === 'Cancel') {
            _this.editor.windowManager.close();
            return typeof callback === "function" ? callback(null, null) : void 0;
          }
        };
      })(this);
      this.editor.windowManager.open({
        title: 'Open file...',
        url: 'filedialog/filedialog.html',
        width: 600,
        height: 400,
        buttons: [
          {
            text: 'Open',
            subtype: 'primary',
            onclick: (function(_this) {
              return function() {
                return _this.buttonClickedHandler('Open');
              };
            })(this)
          }, {
            text: 'Cancel',
            onclick: (function(_this) {
              return function() {
                return _this.buttonClickedHandler('Cancel');
              };
            })(this)
          }
        ]
      }, {
        fsName: this.fileSystem,
        mode: 'open file'
      });
      return refreshDialog();
    };

    LoadSave.prototype.handleOpen = function(callback) {
      if (callback == null) {
        callback = (function(_this) {
          return function() {
            return _this.tryToOpen();
          };
        })(this);
      }
      if (!this.documentDirty) {
        return callback();
      }
      return this.editor.windowManager.open({
        title: 'Save first?',
        buttons: [
          {
            text: 'Save',
            onclick: (function(_this) {
              return function() {
                _this.editor.windowManager.close();
                return _this.tryToSave(function(success) {
                  if (success) {
                    return callback();
                  }
                });
              };
            })(this)
          }, {
            text: 'Discard',
            onclick: (function(_this) {
              return function() {
                _this.editor.windowManager.close();
                return callback();
              };
            })(this)
          }, {
            text: 'Cancel',
            onclick: (function(_this) {
              return function() {
                return _this.editor.windowManager.close();
              };
            })(this)
          }
        ]
      });
    };

    LoadSave.prototype.tellDialog = function() {
      var args, frame, frames, _i, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      frames = document.getElementsByTagName('iframe');
      for (_i = 0, _len = frames.length; _i < _len; _i++) {
        frame = frames[_i];
        if ('filedialog/filedialog.html' === frame.getAttribute('src')) {
          return frame.contentWindow.postMessage(args, '*');
        }
      }
    };

    LoadSave.prototype.manageFiles = function() {
      return this.editor.windowManager.open({
        title: 'Manage files',
        url: 'filedialog/filedialog.html',
        width: 700,
        height: 500,
        buttons: [
          {
            text: 'New folder',
            onclick: (function(_this) {
              return function() {
                return _this.tellDialog('buttonClicked', 'New folder');
              };
            })(this)
          }, {
            text: 'Done',
            onclick: (function(_this) {
              return function() {
                return _this.editor.windowManager.close();
              };
            })(this)
          }
        ]
      }, {
        fsName: this.fileSystem,
        mode: 'manage files'
      });
    };

    LoadSave.prototype.installOpenHandler = function(handler) {
      return this.replaceInternalHandler('tryToOpen', handler);
    };

    LoadSave.prototype.installSaveHandler = function(handler) {
      return this.replaceInternalHandler('tryToSave', handler);
    };

    LoadSave.prototype.installManageFilesHandler = function(handler) {
      return this.replaceInternalHandler('manageFiles', handler);
    };

    LoadSave.prototype.replaceInternalHandler = function(internalName, newHandler) {
      var _base, _ref;
      if (newHandler != null) {
        if ((_base = (this.handlerBackups != null ? this.handlerBackups : this.handlerBackups = {}))[internalName] == null) {
          _base[internalName] = this[internalName];
        }
        return this[internalName] = newHandler;
      } else if (((_ref = this.handlerBackups) != null ? _ref[internalName] : void 0) != null) {
        return this[internalName] = this.handlerBackups[internalName];
      }
    };

    return LoadSave;

  })();

  tinymce.PluginManager.add('loadsave', function(editor, url) {
    return editor.LoadSave = new LoadSave(editor);
  });

  window.onmessage = function(event) {
    var handlerName, instance, _i, _len, _ref;
    handlerName = "" + event.data[0] + "Handler";
    _ref = LoadSave.prototype.instances;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      instance = _ref[_i];
      if (instance.hasOwnProperty(handlerName)) {
        return instance[handlerName].apply(null, event.data.slice(1));
      }
    }
  };

  window.setAppName = function(newname) {
    if (newname == null) {
      newname = null;
    }
    return LoadSave.prototype.appName = newname;
  };

  editor = null;

  setIndexPage = function(URL) {
    return editor.indexURL = URL;
  };

  getIndexPage = function() {
    return editor.indexURL;
  };

  setAPIPage = function(URL) {
    return editor.APIURL = URL;
  };

  getAPIPage = function() {
    return editor.APIURL;
  };

  window.embedMetadata = embedMetadata = function(documentHTML, metadataObject) {
    var encoding;
    if (metadataObject == null) {
      metadataObject = {};
    }
    encoding = encodeURIComponent(JSON.stringify(metadataObject));
    return "<span id='metadata' style='display: none;' >" + encoding + "</span>" + documentHTML;
  };

  window.extractMetadata = extractMetadata = function(html) {
    var match, re;
    re = /^<span[^>]+id=.metadata.[^>]*>([^<]*)<\/span>/;
    if (match = re.exec(html)) {
      return {
        metadata: JSON.parse(decodeURIComponent(match[1])),
        document: html.slice(match[0].length)
      };
    } else {
      return {
        metadata: null,
        document: html
      };
    }
  };

  getPageData = function(pageName, rvprop, callback) {
    var xhr;
    xhr = new XMLHttpRequest();
    xhr.addEventListener('load', function() {
      var content, e, json, object;
      json = this.responseText;
      try {
        object = JSON.parse(json);
      } catch (_error) {
        e = _error;
        callback(null, 'Invalid response format.\nShould be JSON:\n' + json);
        return;
      }
      try {
        content = object.query.pages[0].revisions[0][rvprop];
      } catch (_error) {
        e = _error;
        callback(null, 'No such page on wiki.\nRaw reply:\n' + json);
        return;
      }
      return callback(content, null);
    });
    xhr.open('GET', editor.MediaWiki.getAPIPage() + '?action=query&titles=' + encodeURIComponent(pageName) + '&prop=revisions' + '&rvprop=' + rvprop + '&rvparse' + '&format=json&formatversion=2');
    xhr.setRequestHeader('Api-User-Agent', 'webLurch application');
    return xhr.send();
  };

  getPageContent = function(pageName, callback) {
    return getPageData(pageName, 'content', callback);
  };

  getPageTimestamp = function(pageName, callback) {
    return getPageData(pageName, 'timestamp', callback);
  };

  importPage = function(pageName, callback) {
    return editor.MediaWiki.getPageContent(pageName, function(content, error) {
      var document, metadata, _ref;
      if (error) {
        editor.Dialogs.alert({
          title: 'Wiki Error',
          message: "<p>Error loading content from wiki:</p> <p>" + (error.split('\n')[0]) + "</p>"
        });
        console.log(error);
        if (typeof callback === "function") {
          callback(false);
        }
      }
      _ref = extractMetadata(content), metadata = _ref.metadata, document = _ref.document;
      if (metadata == null) {
        editor.Dialogs.alert({
          title: 'Not a Lurch document',
          message: '<p><b>The wiki page that you attempted to import is not a Lurch document.</b></p> <p>Although it is possible to import any wiki page into Lurch, it does not work well to edit and re-post such pages to the wiki.</p> <p>To edit a non-Lurch wiki page, visit the page on the wiki and edit it there.</p>'
        });
        if (typeof callback === "function") {
          callback(false);
        }
      }
      editor.setContent(document);
      return typeof callback === "function" ? callback(document, metadata) : void 0;
    });
  };

  getPageMetadata = function(pageName, callback) {
    return editor.MediaWiki.getPageContent(pageName, function(content, error) {
      return typeof callback === "function" ? callback(error ? null : extractMetadata(content).metadata) : void 0;
    });
  };

  login = function(username, password, callback, token) {
    var URL, xhr;
    xhr = new XMLHttpRequest();
    xhr.addEventListener('load', function() {
      var e, json, object, _ref, _ref1, _ref2;
      json = this.responseText;
      try {
        object = JSON.parse(json);
      } catch (_error) {
        e = _error;
        callback(null, 'Invalid JSON response: ' + json);
        return;
      }
      if ((object != null ? (_ref = object.login) != null ? _ref.result : void 0 : void 0) === 'Success') {
        return callback(true, null);
      } else if ((object != null ? (_ref1 = object.login) != null ? _ref1.result : void 0 : void 0) === 'NeedToken') {
        return editor.MediaWiki.login(username, password, callback, object.login.token);
      } else {
        return callback(null, 'Login error of type ' + (object != null ? (_ref2 = object.login) != null ? _ref2.result : void 0 : void 0));
      }
    });
    URL = editor.MediaWiki.getAPIPage() + '?action=login' + '&lgname=' + encodeURIComponent(username) + '&lgpassword=' + encodeURIComponent(password) + '&format=json&formatversion=2';
    if (token) {
      URL += '&lgtoken=' + token;
    }
    xhr.open('POST', URL);
    xhr.setRequestHeader('Api-User-Agent', 'webLurch application');
    return xhr.send();
  };

  exportPage = function(pageName, content, callback) {
    var xhr;
    xhr = new XMLHttpRequest();
    xhr.addEventListener('load', function() {
      var e, json, object, token, xhr2, _ref, _ref1;
      json = this.responseText;
      try {
        object = JSON.parse(json);
      } catch (_error) {
        e = _error;
        callback(null, 'Invalid JSON response: ' + json);
        return;
      }
      if (!(object != null ? (_ref = object.query) != null ? (_ref1 = _ref.tokens) != null ? _ref1.csrftoken : void 0 : void 0 : void 0)) {
        callback(null, 'No token provided: ' + json);
        return;
      }
      xhr2 = new XMLHttpRequest();
      xhr2.addEventListener('load', function() {
        var _ref2;
        json = this.responseText;
        try {
          object = JSON.parse(json);
        } catch (_error) {
          e = _error;
          callback(null, 'Invalid JSON response: ' + json);
          return;
        }
        if ((object != null ? (_ref2 = object.edit) != null ? _ref2.result : void 0 : void 0) !== 'Success') {
          callback(null, 'Edit failed: ' + json);
          return;
        }
        return callback('Success', null);
      });
      content = formatContentForWiki(content);
      xhr2.open('POST', editor.MediaWiki.getAPIPage() + '?action=edit' + '&title=' + encodeURIComponent(pageName) + '&text=' + encodeURIComponent(content) + '&summary=' + encodeURIComponent('posted from Lurch') + '&contentformat=' + encodeURIComponent('text/x-wiki') + '&contentmodel=' + encodeURIComponent('wikitext') + '&format=json&formatversion=2', true);
      token = 'token=' + encodeURIComponent(object.query.tokens.csrftoken);
      xhr2.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
      xhr2.setRequestHeader('Api-User-Agent', 'webLurch application');
      return xhr2.send(token);
    });
    xhr.open('GET', editor.MediaWiki.getAPIPage() + '?action=query&meta=tokens' + '&format=json&formatversion=2');
    xhr.setRequestHeader('Api-User-Agent', 'webLurch application');
    return xhr.send();
  };

  formatContentForWiki = function(editorHTML) {
    var charRE, closeRE, decoder, depth, match, openRE, result, tagName, toReplace;
    result = '';
    depth = 0;
    openRE = /^<([^ >]+)\s*([^>]+)?>/i;
    closeRE = /^<\/([^ >]+)\s*>/i;
    charRE = /^&([a-z0-9]+|#[0-9]+);/i;
    toReplace = ['img', 'span', 'var', 'sup'];
    decoder = document.createElement('div');
    while (editorHTML.length > 0) {
      if (match = closeRE.exec(editorHTML)) {
        tagName = match[1].toLowerCase();
        if (__indexOf.call(toReplace, tagName) >= 0) {
          depth--;
          result += "</htmltag" + depth + ">";
        } else {
          result += match[0];
        }
        editorHTML = editorHTML.slice(match[0].length);
      } else if (match = openRE.exec(editorHTML)) {
        tagName = match[1].toLowerCase();
        if (__indexOf.call(toReplace, tagName) >= 0) {
          result += "<htmltag" + depth + " tagname='" + tagName + "' " + match[2] + ">";
          if (!/\/\s*$/.test(match[2])) {
            depth++;
          }
        } else {
          result += match[0];
        }
        editorHTML = editorHTML.slice(match[0].length);
      } else if (match = charRE.exec(editorHTML)) {
        decoder.innerHTML = match[0];
        result += decoder.textContent;
        editorHTML = editorHTML.slice(match[0].length);
      } else {
        result += editorHTML[0];
        editorHTML = editorHTML.slice(1);
      }
    }
    return result;
  };

  tinymce.PluginManager.add('mediawiki', function(ed, url) {
    return (editor = ed).MediaWiki = {
      setIndexPage: setIndexPage,
      getIndexPage: getIndexPage,
      setAPIPage: setAPIPage,
      getAPIPage: getAPIPage,
      login: login,
      getPageContent: getPageContent,
      getPageTimestamp: getPageTimestamp,
      importPage: importPage,
      exportPage: exportPage,
      embedMetadata: embedMetadata,
      extractMetadata: extractMetadata,
      getPageMetadata: getPageMetadata
    };
  });

  Overlay = (function() {
    function Overlay(editor) {
      this.editor = editor;
      this.redrawContents = __bind(this.redrawContents, this);
      this.editor.on('init', (function(_this) {
        return function() {
          _this.container = _this.editor.getContentAreaContainer();
          _this.canvas = document.createElement('canvas');
          ($(_this.container)).after(_this.canvas);
          _this.canvas.style.position = 'absolute';
          _this.canvas.style['background-color'] = 'rgba(0,0,0,0)';
          _this.canvas.style['pointer-events'] = 'none';
          return _this.canvas.style['z-index'] = '10';
        };
      })(this));
      this.drawHandlers = [];
      this.editor.on('NodeChange', this.redrawContents);
      ($(window)).resize(this.redrawContents);
    }

    Overlay.prototype.redrawContents = function(event) {
      var context, doDrawing, e, _i, _len, _ref, _ref1, _results;
      this.positionCanvas();
      if (!(context = (_ref = this.canvas) != null ? _ref.getContext('2d') : void 0)) {
        return;
      }
      this.clearCanvas(context);
      context.translate(0, ($(this.container)).position().top);
      _ref1 = this.drawHandlers;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        doDrawing = _ref1[_i];
        try {
          _results.push(doDrawing(this.canvas, context));
        } catch (_error) {
          e = _error;
          _results.push(console.log("Error in overlay draw function: " + e.stack));
        }
      }
      return _results;
    };

    Overlay.prototype.addDrawHandler = function(drawFunction) {
      return this.drawHandlers.push(drawFunction);
    };

    Overlay.prototype.getEditorFrame = function() {
      var frame, _i, _len, _ref;
      _ref = window.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        if (frame.document === this.editor.getDoc()) {
          return frame;
        }
      }
      return null;
    };

    Overlay.prototype.positionCanvas = function() {
      var can, con;
      con = $(this.container);
      can = $(this.canvas);
      if (con.position() == null) {
        return;
      }
      can.css('top', 0);
      can.css('left', con.position().left);
      can.width(con.width());
      can.height(con.position().top + con.height());
      this.canvas.width = can.width();
      return this.canvas.height = can.height();
    };

    Overlay.prototype.clearCanvas = function(context) {
      return context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    return Overlay;

  })();

  tinymce.PluginManager.add('overlay', function(editor, url) {
    editor.Overlay = new Overlay(editor);
    return editor.on('init', function(event) {
      return ($(editor.getWin())).scroll(function() {
        return editor.Overlay.redrawContents();
      });
    });
  });

  plugin = {};

  plugin.addCategory = function(name) {
    return plugin[name] = {
      get: function(key) {
        return window.localStorage.getItem(key);
      },
      set: function(key, value) {
        return window.localStorage.setItem(key, value);
      },
      setup: function(div) {
        return null;
      },
      teardown: function(div) {
        return null;
      },
      showUI: function() {
        return plugin.showUI(name);
      }
    };
  };

  plugin.showUI = function(category) {
    var buttons, categoryTitle, div, wins;
    div = null;
    buttons = [
      {
        type: 'button',
        text: 'Cancel',
        onclick: function(event) {
          return tinymce.activeEditor.windowManager.close();
        }
      }, {
        type: 'button',
        text: 'Save',
        subtype: 'primary',
        onclick: function(event) {
          plugin[category].teardown(div);
          return tinymce.activeEditor.windowManager.close();
        }
      }
    ];
    categoryTitle = category[0].toUpperCase() + category.slice(1).toLowerCase() + ' Settings';
    tinymce.activeEditor.windowManager.open({
      title: categoryTitle,
      url: 'about:blank',
      width: 500,
      height: 400,
      buttons: buttons
    });
    wins = tinymce.activeEditor.windowManager.windows;
    div = wins[wins.length - 1].getEl().getElementsByClassName('mce-container-body')[0];
    div.innerHTML = '';
    return plugin[category].setup(div);
  };

  plugin.UI = {};

  plugin.UI.info = function(name, id) {
    return plugin.UI.tr("<td style='width: 100%; text-align: center; white-space: normal;' >" + name + "</td>", id);
  };

  plugin.UI.heading = function(name, id) {
    return plugin.UI.info("<hr style='border: 1px solid black;'> <span style='font-size: 20px;'>" + name + "</span> <hr style='border: 1px solid black;'>", id);
  };

  plugin.UI.readOnly = function(label, data, id) {
    return plugin.UI.tpair(label, data, id);
  };

  plugin.UI.text = function(label, id, initial) {
    return plugin.UI.tpair(label, "<input type='text' id='" + id + "' value='" + initial + "' style='border-width: 2px; border-style: inset;'/>");
  };

  plugin.UI.password = function(label, id, initial) {
    return plugin.UI.tpair(label, "<input type='password' id='" + id + "' value='" + initial + "' style='border-width: 2px; border-style: inset;'/>");
  };

  plugin.UI.checkbox = function(text, checked, id, optionalDescription) {
    var result;
    if (checked == null) {
      checked = false;
    }
    checked = checked ? ' checked' : '';
    result = plugin.UI.generalPair("<input type='checkbox' id='" + id + "' " + checked + "/>", "<b>" + text + "</b>", null, 10);
    if (optionalDescription) {
      result += plugin.UI.generalPair('', "<p>" + optionalDescription + "</p>", null, 10);
    }
    return result;
  };

  plugin.UI.radioButton = function(text, groupName, checked, id, optionalDescription) {
    var result;
    if (checked == null) {
      checked = false;
    }
    checked = checked ? ' checked' : '';
    result = plugin.UI.generalPair("<input type='radio' name='" + groupName + "' id='" + id + "' " + checked + "/>", "<b>" + text + "</b>", null, 10);
    if (optionalDescription) {
      result += plugin.UI.generalPair('', "<p>" + optionalDescription + "</p>", null, 10);
    }
    return result;
  };

  plugin.UI.button = function(text, id) {
    return "<input type='button' " + (id != null ? " id='" + id + "'" : '') + " value='" + text + "' style='border: 1px solid #999999; background: #dddddd; padding: 2px; margin: 2px;' onmouseover='this.style.background=\"#eeeeee\";' onmouseout='this.style.background=\"#dddddd\";'/>";
  };

  plugin.UI.tr = function(content, id) {
    return ("<table border=0 cellpadding=0 cellspacing=10 style='width: 100%;' " + (id != null ? " id='" + id + "'" : '') + "> <tr style='width: 100%; vertical-align: middle;'>") + content + '</tr></table>';
  };

  plugin.UI.tpair = function(left, right, id) {
    return plugin.UI.tr("<td style='width: 50%; text-align: right; vertical-align: middle;'><b>" + left + ":</b></td> <td style='width: 50%; text-align: left; vertical-align: middle;'>" + right + "</td>", id);
  };

  plugin.UI.generalPair = function(left, right, id, percent, align) {
    if (align == null) {
      align = 'left';
    }
    return plugin.UI.tr("<td style='width: " + percent + "%; text-align: " + align + "; vertical-align: middle;'>" + left + "</td> <td style='width: " + (100 - percent) + "%; text-align: left; vertical-align: middle;'>" + right + "</td>", id);
  };

  tinymce.PluginManager.add('settings', function(editor, url) {
    return editor.Settings = plugin;
  });

  setAppName('Untitled');

  if (window.groupTypes == null) {
    window.groupTypes = [
      {
        name: 'example',
        text: 'Example group',
        imageHTML: '[',
        openImageHTML: ']',
        closeImageHTML: '[]',
        tooltip: 'Wrap text in a group',
        color: '#666666'
      }
    ];
  }

  if (window.groupToolbarButtons == null) {
    window.groupToolbarButtons = {};
  }

  if (window.groupMenuItems == null) {
    window.groupMenuItems = {};
  }

  if (window.pluginsToLoad == null) {
    window.pluginsToLoad = [];
  }

  if (window.menuBarIcon == null) {
    window.menuBarIcon = {};
  }

  if (window.defaultEditorStyles == null) {
    window.defaultEditorStyles = {
      fontSize: '16px',
      fontFamily: 'Verdana, Arial, Helvetica, sans-serif'
    };
  }

  if (window.helpAboutText == null) {
    window.helpAboutText = 'webLurch\n\nalpha\n\nnot yet intended for non-developer use';
  }

  $(function() {
    var groupTypeNames, p, type;
    editor = document.createElement('textarea');
    editor.setAttribute('id', 'editor');
    document.body.appendChild(editor);
    maybeSetupTestRecorder();
    groupTypeNames = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = groupTypes.length; _i < _len; _i++) {
        type = groupTypes[_i];
        _results.push(type.name);
      }
      return _results;
    })();
    return tinymce.init({
      selector: '#editor',
      auto_focus: 'editor',
      browser_spellcheck: true,
      gecko_spellcheck: true,
      statusbar: false,
      paste_data_images: true,
      plugins: 'advlist table charmap colorpicker image link importcss paste print save searchreplace textcolor fullscreen -loadsave -overlay -groups -equationeditor -dependencies -dialogs ' + ((function() {
        var _i, _len, _ref, _results;
        _ref = window.pluginsToLoad;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push("-" + p);
        }
        return _results;
      })()).join(' '),
      object_resizing: ':not(img.grouper)',
      toolbar: ['newfile openfile savefile managefiles | print | undo redo | cut copy paste | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent blockquote | table', 'fontselect styleselect | bold italic underline textcolor subscript superscript removeformat | link unlink | charmap image | spellchecker searchreplace | equationeditor | ' + groupTypeNames.join(' ') + ' connect' + moreToolbarItems()],
      menu: {
        file: {
          title: 'File',
          items: 'newfile openfile | savefile saveas | managefiles | print' + moreMenuItems('file')
        },
        edit: {
          title: 'Edit',
          items: 'undo redo | cut copy paste pastetext | selectall' + moreMenuItems('edit')
        },
        insert: {
          title: 'Insert',
          items: 'link media | template hr | me' + moreMenuItems('insert')
        },
        view: {
          title: 'View',
          items: 'visualaid hideshowgroups' + moreMenuItems('view')
        },
        format: {
          title: 'Format',
          items: 'bold italic underline strikethrough superscript subscript | formats | removeformat' + moreMenuItems('format')
        },
        table: {
          title: 'Table',
          items: 'inserttable tableprops deletetable | cell row column' + moreMenuItems('table')
        },
        help: {
          title: 'Help',
          items: 'about website' + moreMenuItems('help')
        }
      },
      contextmenu: 'link image inserttable | cell row column deletetable' + moreMenuItems('contextmenu'),
      groupTypes: groupTypes,
      setup: function(editor) {
        var data, name, _ref, _ref1;
        editor.addMenuItem('about', {
          text: 'About...',
          context: 'help',
          onclick: function() {
            return editor.Dialogs.alert({
              title: 'webLurch',
              message: typeof helpAboutText !== "undefined" && helpAboutText !== null ? helpAboutText : ''
            });
          }
        });
        editor.addMenuItem('website', {
          text: 'Documentation',
          context: 'help',
          onclick: function() {
            return window.open('http://nathancarter.github.io/weblurch', '_blank');
          }
        });
        _ref = window.groupMenuItems;
        for (name in _ref) {
          if (!__hasProp.call(_ref, name)) continue;
          data = _ref[name];
          editor.addMenuItem(name, data);
        }
        _ref1 = window.groupToolbarButtons;
        for (name in _ref1) {
          if (!__hasProp.call(_ref1, name)) continue;
          data = _ref1[name];
          editor.addButton(name, data);
        }
        return editor.on('init', function() {
          var filemenu, icon, key, value, _ref2, _ref3;
          installDOMUtilitiesIn(editor.getWin());
          _ref2 = window.defaultEditorStyles;
          for (key in _ref2) {
            if (!__hasProp.call(_ref2, key)) continue;
            value = _ref2[key];
            editor.getBody().style[key] = value;
          }
          setTimeout(function() {
            var h, walk, _i, _len, _ref3, _results;
            editor.execCommand('mceFullScreen');
            walk = editor.iframeElement;
            while (walk && walk !== editor.container) {
              if (walk === editor.iframeElement.parentNode) {
                walk.style.height = 'auto';
              } else {
                walk.style.height = '100%';
              }
              walk = walk.parentNode;
            }
            _ref3 = editor.getDoc().getElementsByTagName('html');
            _results = [];
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              h = _ref3[_i];
              _results.push(h.style.height = 'auto');
            }
            return _results;
          }, 0);
          editor.dom.loadCSS('./eqed/mathquill.css');
          if (((_ref3 = window.menuBarIcon) != null ? _ref3.src : void 0) != null) {
            filemenu = (editor.getContainer().getElementsByClassName('mce-menubtn'))[0];
            icon = document.createElement('img');
            icon.setAttribute('src', window.menuBarIcon.src);
            icon.style.width = window.menuBarIcon.width;
            icon.style.height = window.menuBarIcon.height;
            icon.style.padding = window.menuBarIcon.padding;
            filemenu.insertBefore(icon, filemenu.childNodes[0]);
          }
          editor.getBody().addEventListener('focus', function() {
            if (editor.windowManager.getWindows().length !== 0) {
              return editor.windowManager.close();
            }
          });
          editor.on('KeyDown', function(event) {
            if (event.keyCode === 9) {
              event.preventDefault();
              return editor.insertContent('&emsp;');
            }
          });
          return typeof window.afterEditorReady === "function" ? window.afterEditorReady(editor) : void 0;
        });
      }
    });
  });

  moreMenuItems = function(menuName) {
    var k, names;
    names = window.groupMenuItems.hasOwnProperty("" + menuName + "_order") ? window.groupMenuItems["" + menuName + "_order"] : ((function() {
      var _i, _len, _ref, _results;
      _ref = Object.keys(window.groupMenuItems);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        k = _ref[_i];
        if (window.groupMenuItems[k].context === menuName) {
          _results.push(k);
        }
      }
      return _results;
    })()).join(' ');
    if (names.length && names.slice(0, 2) !== '| ') {
      return "| " + names;
    } else {
      return '';
    }
  };

  moreToolbarItems = function() {
    var names, _ref;
    names = ((_ref = window.groupToolbarButtons.order) != null ? _ref : Object.keys(window.groupToolbarButtons)).join(' ');
    if (window.useGroupConnectionsUI) {
      names = "connect " + names;
    }
    if (names.length && names.slice(0, 2) !== '| ') {
      return "| " + names;
    } else {
      return '';
    }
  };

  window.addHelpMenuSourceCodeLink = function(path) {
    var flash;
    if (window.groupMenuItems == null) {
      window.groupMenuItems = {};
    }
    window.groupMenuItems.sourcecode = {
      text: 'View documented source code',
      context: 'help',
      onclick: function() {
        return window.location.href = 'http://github.com/' + 'nathancarter/weblurch/blob/master/' + path;
      }
    };
    window.groupMenuItems.tutorial = {
      text: 'View developer tutorial',
      context: 'help',
      onclick: function() {
        return window.location.href = 'http://github.com/' + 'nathancarter/weblurch/blob/master/doc/tutorial.md';
      }
    };
    flash = function(count, delay, elts) {
      if (count-- <= 0) {
        return;
      }
      return elts.fadeOut(delay).fadeIn(delay, function() {
        return flash(count, delay, elts);
      });
    };
    return setTimeout(function() {
      return flash(3, 500, ($('.mce-menubtn')).filter(function(index, element) {
        return element.textContent.trim() === 'Help';
      }));
    }, 1000);
  };

  maybeSetupTestRecorder = function() {
    var installListeners, installed, testwin;
    if (location.search === '?test') {
      testwin = open('./testrecorder.html', 'recording', "status=no, location=no, toolbar=no, menubar=no, left=" + (window.screenX + ($(window)).width()) + ", top=" + window.screenY + ", width=400, height=600");
      if (!testwin) {
        alert('You have asked to run webLurch in test-recording mode, which requires a popup window.  Your browser has blocked the popup window.  Change its settings or allow this popup to use test-recording mode.');
      }
      installed = [];
      return (installListeners = function() {
        var button, e, findAll, notSupported, object, _fn, _i, _j, _len, _len1, _ref, _ref1;
        notSupported = function(whatYouDid) {
          return alert("You " + whatYouDid + ", which the test recorder does not yet support.  The current test has therefore become corrupted, and you should reload this page and start your test again.  You will need to limit yourself to using only supported keys, menu items, and mouse operations.");
        };
        try {
          if (__indexOf.call(installed, 'keypress') < 0) {
            tinymce.activeEditor.on('keypress', function(event) {
              var letter;
              letter = String.fromCharCode(event.keyCode);
              if (/[A-Za-z0-9 ]/.test(letter)) {
                return testwin.editorKeyPress(event.keyCode, event.shiftKey, event.ctrlKey, event.altKey);
              } else {
                return notSupported("pressed the key with code " + event.keyCode);
              }
            });
            installed.push('keypress');
          }
          if (__indexOf.call(installed, 'keyup') < 0) {
            tinymce.activeEditor.on('keyup', function(event) {
              var conversion, ignore, letter, _ref;
              letter = String.fromCharCode(event.keyCode);
              if (/[A-Za-z0-9 ]/.test(letter)) {
                return;
              }
              ignore = [16, 17, 18, 91];
              if (_ref = event.keyCode, __indexOf.call(ignore, _ref) >= 0) {
                return;
              }
              conversion = {
                8: 'backspace',
                13: 'enter',
                35: 'end',
                36: 'home',
                37: 'left',
                38: 'up',
                39: 'right',
                40: 'down',
                46: 'delete'
              };
              if (conversion.hasOwnProperty(event.keyCode)) {
                return testwin.editorKeyPress(conversion[event.keyCode], event.shiftKey, event.ctrlKey, event.altKey);
              } else {
                return notSupported("pressed the key with code " + event.keyCode);
              }
            });
            installed.push('keyup');
          }
          if (__indexOf.call(installed, 'click') < 0) {
            tinymce.activeEditor.on('click', function(event) {
              if (event.shiftKey) {
                return notSupported("shift-clicked");
              } else if (event.ctrlKey) {
                return notSupported("ctrl-clicked");
              } else if (event.altKey) {
                return notSupported("alt-clicked");
              } else {
                return testwin.editorMouseClick(event.clientX, event.clientY);
              }
            });
            installed.push('click');
          }
          findAll = function(type) {
            return Array.prototype.slice.apply(tinymce.activeEditor.theme.panel.find(type));
          };
          if (__indexOf.call(installed, 'buttons') < 0) {
            _ref = findAll('button');
            _fn = function(button) {
              return button.on('click', function() {
                return testwin.buttonClicked(button.settings.icon);
              });
            };
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              button = _ref[_i];
              _fn(button);
            }
            installed.push('buttons');
          }
          _ref1 = __slice.call(findAll('splitbutton')).concat(__slice.call(findAll('listbox')), __slice.call(findAll('menubutton')));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            object = _ref1[_j];
            object.disabled(true);
          }
          return testwin.enterReadyState();
        } catch (_error) {
          e = _error;
          return setTimeout(installListeners, 100);
        }
      })();
    }
  };

}).call(this);

//# sourceMappingURL=app.js.map
