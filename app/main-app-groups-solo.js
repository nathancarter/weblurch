// Generated by CoffeeScript 1.8.0
(function() {
  var changeAttributeAction,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  window.groupTypes = [
    {
      name: 'expression',
      text: 'Expression',
      imageHTML: '<font color="#996666">[ ]</font>',
      openImageHTML: '<font color="#996666">[</font>',
      closeImageHTML: '<font color="#996666">]</font>',
      tooltip: 'Make the selected text an expression',
      color: '#996666',
      shortcut: 'meta+[',
      LaTeXshortcut: '\\[',
      connectionRequest: function(from, to) {
        var reachable;
        reachable = function(source, target) {
          var c, next, _i, _len, _ref;
          if (source === target) {
            return true;
          }
          _ref = source.connectionsOut();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            next = tinymce.activeEditor.Groups[c[1]];
            if (reachable(next, target)) {
              return true;
            }
          }
          return false;
        };
        if (reachable(to, from)) {
          return from.plugin.editor.Dialogs.alert({
            title: 'Cannot connect expressions',
            message: 'Forming that connection would create a cycle of connections among expressions, which is not permitted.'
          });
        } else {
          return tinymce.activeEditor.undoManager.transact(function() {
            from.connect(to);
            if (!from.get('key')) {
              from.set('key', 'label');
            }
            if (!from.get('keyposition')) {
              return from.set('keyposition', 'arrow');
            }
          });
        }
      },
      connections: function(group) {
        var connection, cxn, ins, outs, result, source, t, _i, _j, _len, _len1, _ref, _ref1;
        if (group instanceof ProtoGroup) {
          result = (_ref = group.connections) != null ? _ref : [];
          for (_i = 0, _len = result.length; _i < _len; _i++) {
            connection = result[_i];
            if (connection instanceof Array) {
              if (__indexOf.call(connection, 2) < 0) {
                connection[2] = '';
              }
              connection[3] = function(context) {
                context.globalAlpha = 0.5;
                return context.setLineDash([2, 2]);
              };
            }
          }
          return result;
        }
        outs = group.connectionsOut();
        ins = group.connectionsIn();
        _ref1 = __slice.call(ins).concat(__slice.call(outs));
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          cxn = _ref1[_j];
          source = tinymce.activeEditor.Groups[cxn[0]];
          if (source.get('keyposition') === 'arrow') {
            cxn[2] = source.get('key');
          }
          if (source.get('key') === 'premise') {
            cxn[3] = function(context) {
              return context.setLineDash([3, 3]);
            };
          }
        }
        return __slice.call(outs).concat(__slice.call(ins), __slice.call((function() {
            var _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = outs.length; _k < _len2; _k++) {
              t = outs[_k];
              _results.push(t[1]);
            }
            return _results;
          })()), __slice.call((function() {
            var _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = ins.length; _k < _len2; _k++) {
              t = ins[_k];
              _results.push(t[0]);
            }
            return _results;
          })()));
      },
      tagContents: function(group) {
        if (group instanceof ProtoGroup) {
          return group.tagContents;
        } else if (group.get('keyposition') === 'source') {
          return group.get('key');
        } else {
          return null;
        }
      },
      tagMenuItems: function(group) {
        var result;
        result = [];
        if (group instanceof ProtoGroup) {
          result.push({
            text: 'Accept suggestion',
            shortcut: 'Meta+J',
            onclick: function() {
              return group.promote();
            }
          });
        } else if (group.connectionsOut().length > 0 && group.get('keyposition') === 'source') {
          result.push({
            text: "Move \"" + (group.get('key')) + "\" onto arrow",
            onclick: function() {
              return tinymce.activeEditor.undoManager.transact(function() {
                return group.set('keyposition', 'arrow');
              });
            }
          });
          result.push(changeAttributeAction(group));
        }
        return result;
      },
      contextMenuItems: function(group) {
        var allHaveJustThisGroupAsAttributeForKey, anySourceModifiesAnotherGroup, connection, connections, key, languages, last, result, source, sources, target, targets, _i, _j, _len, _len1;
        result = [];
        connections = group.connectionsOut();
        key = group.get('key');
        if (connections.length > 0) {
          if (group.get('keyposition') === 'arrow') {
            result.push({
              text: "Move \"" + (group.get('key')) + "\" onto attribute",
              onclick: function() {
                return tinymce.activeEditor.undoManager.transact(function() {
                  return group.set('keyposition', 'source');
                });
              }
            });
          }
          result.push(changeAttributeAction(group));
        }
        if (connections.length > 0 && key !== 'premise') {
          targets = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = connections.length; _i < _len; _i++) {
              connection = connections[_i];
              _results.push(tinymce.activeEditor.Groups[connection[1]]);
            }
            return _results;
          })();
          allHaveJustThisGroupAsAttributeForKey = true;
          for (_i = 0, _len = targets.length; _i < _len; _i++) {
            target = targets[_i];
            if (target.attributeGroupsForKey(key).length > 1) {
              allHaveJustThisGroupAsAttributeForKey = false;
              break;
            }
          }
          if (allHaveJustThisGroupAsAttributeForKey) {
            result.push({
              text: 'Hide this attribute',
              onclick: function() {
                var doIt, numPremises, warnings;
                doIt = function() {
                  return tinymce.activeEditor.undoManager.transact(function() {
                    var index, last, _j, _len1, _results;
                    _results = [];
                    for (index = _j = 0, _len1 = targets.length; _j < _len1; index = ++_j) {
                      target = targets[index];
                      last = index === targets.length - 1;
                      target.embedAttribute(key, last);
                      if (!last) {
                        _results.push(group.connect(targets[index + 1]));
                      } else {
                        _results.push(void 0);
                      }
                    }
                    return _results;
                  });
                };
                warnings = '';
                if (targets.length > 1) {
                  warnings += "You are hiding this attribute in " + targets.length + " expressions.  ";
                }
                numPremises = (group.attributionAncestry(true)).length - (group.attributionAncestry(false)).length;
                if (numPremises > 0) {
                  warnings += "There are " + numPremises + " premise connections that will be broken if you hide that attribute.  ";
                }
                if (warnings.length > 0) {
                  return tinymce.activeEditor.Dialogs.confirm({
                    title: 'Warning',
                    message: "" + warnings + "Continue anyway?",
                    okCallback: doIt
                  });
                } else {
                  return doIt();
                }
              }
            });
          } else if (targets.length === 1) {
            target = targets[0];
            sources = target.attributeGroupsForKey(key);
            anySourceModifiesAnotherGroup = false;
            for (_j = 0, _len1 = sources.length; _j < _len1; _j++) {
              source = sources[_j];
              if (source.connectionsOut().length > 1) {
                anySourceModifiesAnotherGroup = true;
                break;
              }
            }
            if (!anySourceModifiesAnotherGroup) {
              result.push({
                text: 'Hide this attribute',
                onclick: function() {
                  var doIt, numPremises, warnings, _k, _len2;
                  doIt = function() {
                    return tinymce.activeEditor.undoManager.transact(function() {
                      var index, last, _k, _len2, _results;
                      _results = [];
                      for (index = _k = 0, _len2 = targets.length; _k < _len2; index = ++_k) {
                        target = targets[index];
                        last = index === targets.length - 1;
                        target.embedAttribute(key, last);
                        if (!last) {
                          _results.push(group.connect(targets[index + 1]));
                        } else {
                          _results.push(void 0);
                        }
                      }
                      return _results;
                    });
                  };
                  warnings = "You are about to hide not one attribute, but " + sources.length + ", all of type " + key + ".  ";
                  numPremises = 0;
                  for (_k = 0, _len2 = sources.length; _k < _len2; _k++) {
                    source = sources[_k];
                    numPremises += (source.attributionAncestry(true)).length - (source.attributionAncestry(false)).length;
                  }
                  if (numPremises > 0) {
                    warnings += "There are " + numPremises + " premise connections that will be broken if you hide that attribute.  ";
                  }
                  if (warnings.length > 0) {
                    return tinymce.activeEditor.Dialogs.confirm({
                      title: 'Warning',
                      message: "" + warnings + "Continue anyway?",
                      okCallback: doIt
                    });
                  } else {
                    return doIt();
                  }
                }
              });
            }
          }
        }
        result.push({
          text: 'Attributes...',
          onclick: window.attributesActionForGroup(group)
        });
        if ((languages = group.lookupAttributes('code')).length > 0) {
          last = languages[languages.length - 1];
          if (last instanceof Group) {
            last = last.canonicalForm();
          }
          if (last.type === 'st') {
            result.push({
              text: 'Edit as code...',
              onclick: function() {
                return group.plugin.editor.Dialogs.codeEditor({
                  value: group.contentAsCode(),
                  okCallback: function(newCode) {
                    return group.plugin.editor.undoManager.transact(function() {
                      return group.setContentAsCode(newCode);
                    });
                  }
                });
              }
            });
          }
        }
        return result;
      },
      clicked: function(group, numClicks, whichGrouper) {
        if (numClicks === 'double' && whichGrouper === 'close') {
          return tinymce.activeEditor.Dialogs.waiting({
            title: 'Just sit tight',
            message: 'Waiting...',
            work: function(done) {
              return group.computeValidationAsync(function(result) {
                var _ref;
                done();
                return tinymce.activeEditor.Dialogs.alert({
                  title: 'Validation details',
                  message: "<table> <tr><td>Result:</td> <td>" + result.result + "</td></tr> <tr><td>Explanation:</td> <td>" + result.message + "</td></tr> <tr><td>Details:</td> <td>" + ((_ref = result.verbose) != null ? _ref : '(none available)') + "</td></tr> </table>"
                });
              }, true);
            }
          });
        }
      },
      setOutlineStyle: function(group, context) {
        if (group instanceof ProtoGroup) {
          context.globalAlpha = 0.5;
          return context.setLineDash([2, 2]);
        }
      },
      setFillStyle: function(group, context) {
        if (group instanceof ProtoGroup) {
          context.globalAlpha = 0.35;
          return context.setLineDash([2, 2]);
        }
      }
    }
  ];

  window.afterEditorReadyArray.push(function(editor) {
    var findGroupToConnect, groupIsAReason, isAMathExpression, reasonNames, scanForSuggestions, scanRangeForSuggestions;
    reasonNames = ['and+', 'and-', 'or+', 'or-', 'implies+', 'implies-', 'not+', 'not-', 'forall+', 'forall-', 'exists+', 'exists-', '=+', '=-'];
    isAMathExpression = function(text) {
      return /^[ 0-9\.+*\/\^-]+$/.test(text) && /[0-9]/.test(text);
    };
    scanRangeForSuggestions = function(range) {
      var makeProtoGroup, reasonName, text, _i, _len;
      if (editor.Groups.groupsTouchingRange(range).length > 0) {
        return false;
      }
      makeProtoGroup = function(isAReason, tag) {
        var id, partner, result;
        if (tag == null) {
          tag = 'Suggestion:';
        }
        result = new ProtoGroup(range, editor.Groups.groupTypes.expression);
        result.tagContents = isAReason ? 'Reason?' : 'Expression?';
        result.isAReason = isAReason;
        if (partner = findGroupToConnect(range, isAReason)) {
          id = partner.id();
          if (groupIsAReason(partner)) {
            result.connections = [[id, result, ''], id];
          } else {
            result.connections = [[result, id, ''], id];
          }
        }
        return result;
      };
      text = range.toString();
      for (_i = 0, _len = reasonNames.length; _i < _len; _i++) {
        reasonName = reasonNames[_i];
        if (reasonName === text) {
          return makeProtoGroup(true);
        }
      }
      if (isAMathExpression(text)) {
        return makeProtoGroup(false);
      }
      return false;
    };
    findGroupToConnect = function(range, isAReason) {
      var all, basicChecksPass, candidate, hasRightType, index, last, _ref;
      basicChecksPass = function(group) {
        return ((group != null ? group.id() : void 0) != null) && !group.deleted && group.connectionsIn().length === 0 && group.connectionsOut().length === 0;
      };
      hasRightType = function(group) {
        return isAReason !== groupIsAReason(group);
      };
      last = (_ref = ProtoGroup.lastPromoted) != null ? _ref.promotedTo : void 0;
      if (basicChecksPass(last) && hasRightType(last)) {
        return last;
      }
      index = editor.Groups.grouperIndexOfRangeEndpoint(range, true);
      if (index > -1) {
        all = editor.Groups.allGroupers();
        candidate = editor.Groups.grouperToGroup(all[index]);
        if (basicChecksPass(candidate) && hasRightType(candidate)) {
          return candidate;
        }
        candidate = editor.Groups.grouperToGroup(all[index + 1]);
        if (basicChecksPass(candidate) && hasRightType(candidate)) {
          return candidate;
        }
      }
      return null;
    };
    groupIsAReason = function(group) {
      return group.get('key') === 'reason';
    };
    scanForSuggestions = function() {
      var R, length, lengths, maybe, range, reasonName, word, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      range = editor.selection.getRng();
      if (!range.collapsed) {
        return scanRangeForSuggestions(range);
      }
      word = range.cloneRange();
      word.includeWholeWords();
      if (maybe = scanRangeForSuggestions(word)) {
        return maybe;
      }
      lengths = [];
      for (_i = 0, _len = reasonNames.length; _i < _len; _i++) {
        reasonName = reasonNames[_i];
        if (_ref = reasonName.length, __indexOf.call(lengths, _ref) < 0) {
          lengths.push(reasonName.length);
        }
      }
      lengths.sort(function(a, b) {
        return b - a;
      });
      for (_j = 0, _len1 = lengths.length; _j < _len1; _j++) {
        length = lengths[_j];
        _ref1 = allRangesNearCursor(length);
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          R = _ref1[_k];
          if (maybe = scanRangeForSuggestions(R)) {
            return maybe;
          }
        }
      }
      return false;
    };
    editor.on('NodeChange KeyUp change setContent', function(event) {
      var suggestion, _ref;
      editor.Groups.groupTypes.expression.suggestions = (suggestion = scanForSuggestions()) ? [suggestion] : [];
      return (_ref = editor.Overlay) != null ? _ref.redrawContents() : void 0;
    });
    editor.Groups.visibleGroups = function() {
      var _ref;
      return (_ref = editor.Groups.groupTypes.expression.suggestions) != null ? _ref : [];
    };
    return editor.shortcuts.add('Meta+J', '', function() {
      var _ref, _ref1;
      return (_ref = editor.Groups.groupTypes.expression.suggestions) != null ? (_ref1 = _ref[0]) != null ? _ref1.promote() : void 0 : void 0;
    });
  });

  changeAttributeAction = function(group) {
    var menuItem, setKey;
    setKey = function(value) {
      return tinymce.activeEditor.undoManager.transact(function() {
        return group.set('key', value);
      });
    };
    menuItem = function(name) {
      return {
        text: name,
        onclick: function() {
          return setKey(name.toLowerCase());
        }
      };
    };
    return {
      text: 'Change attribute key to...',
      menu: [
        menuItem('Label'), menuItem('Reason'), menuItem('Premise'), menuItem('Rule'), menuItem('Code'), {
          text: 'Other...',
          onclick: function() {
            return tinymce.activeEditor.Dialogs.prompt({
              title: 'Enter new key',
              message: "Change \"" + (group.get('key')) + "\" to what?",
              okCallback: function(newKey) {
                if (!/^[a-zA-Z0-9-_]+$/.test(newKey)) {
                  tinymce.activeEditor.Dialogs.alert({
                    title: 'Invalid key',
                    message: 'Keys can only contain Roman letters, decimal digits, hyphens, and underscores (no spaces or other punctuation).',
                    width: 300,
                    height: 200
                  });
                  return;
                }
                return setKey(newKey);
              }
            });
          }
        }
      ]
    };
  };

}).call(this);

//# sourceMappingURL=main-app-groups-solo.js.map
