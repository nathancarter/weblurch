// Generated by CoffeeScript 1.8.0
(function() {
  var changeAttributeAction,
    __slice = [].slice;

  window.groupTypes = [
    {
      name: 'expression',
      text: 'Expression',
      imageHTML: '<font color="#996666">[ ]</font>',
      openImageHTML: '<font color="#996666">[</font>',
      closeImageHTML: '<font color="#996666">]</font>',
      tooltip: 'Make the selected text an expression',
      color: '#996666',
      shortcut: 'Ctrl+[',
      LaTeXshortcut: '\\[',
      connectionRequest: function(from, to) {
        var reachable;
        reachable = function(source, target) {
          var c, next, _i, _len, _ref;
          if (source === target) {
            return true;
          }
          _ref = source.connectionsOut();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            next = tinymce.activeEditor.Groups[c[1]];
            if (reachable(next, target)) {
              return true;
            }
          }
          return false;
        };
        if (reachable(to, from)) {
          return from.plugin.editor.Dialogs.alert({
            title: 'Cannot connect expressions',
            message: 'Forming that connection would create a cycle of connections among expressions, which is not permitted.'
          });
        } else {
          return tinymce.activeEditor.undoManager.transact(function() {
            from.connect(to);
            if (!from.get('key')) {
              from.set('key', 'label');
            }
            if (!from.get('keyposition')) {
              return from.set('keyposition', 'arrow');
            }
          });
        }
      },
      connections: function(group) {
        var cxn, ins, outs, source, t, _i, _len, _ref;
        outs = group.connectionsOut();
        ins = group.connectionsIn();
        _ref = __slice.call(ins).concat(__slice.call(outs));
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cxn = _ref[_i];
          source = tinymce.activeEditor.Groups[cxn[0]];
          if (source.get('keyposition') === 'arrow') {
            cxn[2] = source.get('key');
          }
          if (source.get('key') === 'premise') {
            cxn[3] = function(context) {
              return context.setLineDash([3, 3]);
            };
          }
        }
        return __slice.call(outs).concat(__slice.call(ins), __slice.call((function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = outs.length; _j < _len1; _j++) {
              t = outs[_j];
              _results.push(t[1]);
            }
            return _results;
          })()), __slice.call((function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = ins.length; _j < _len1; _j++) {
              t = ins[_j];
              _results.push(t[0]);
            }
            return _results;
          })()));
      },
      tagContents: function(group) {
        if (group.get('keyposition') === 'source') {
          return group.get('key');
        } else {
          return null;
        }
      },
      tagMenuItems: function(group) {
        var result;
        result = [];
        if (group.get('keyposition') === 'source') {
          result.push({
            text: "Move \"" + (group.get('key')) + "\" onto arrow",
            onclick: function() {
              return tinymce.activeEditor.undoManager.transact(function() {
                return group.set('keyposition', 'arrow');
              });
            }
          });
          result.push(changeAttributeAction(group));
        }
        return result;
      },
      contextMenuItems: function(group) {
        var allHaveJustThisGroupAsAttributeForKey, anySourceModifiesAnotherGroup, connection, connections, key, result, source, sources, target, targets, _i, _j, _len, _len1;
        result = [];
        if (group.get('keyposition') === 'arrow') {
          result.push({
            text: "Move \"" + (group.get('key')) + "\" onto attribute",
            onclick: function() {
              return tinymce.activeEditor.undoManager.transact(function() {
                return group.set('keyposition', 'source');
              });
            }
          });
        }
        result.push(changeAttributeAction(group));
        connections = group.connectionsOut();
        key = group.get('key');
        if (connections.length > 0 && key !== 'premise') {
          targets = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = connections.length; _i < _len; _i++) {
              connection = connections[_i];
              _results.push(tinymce.activeEditor.Groups[connection[1]]);
            }
            return _results;
          })();
          allHaveJustThisGroupAsAttributeForKey = true;
          for (_i = 0, _len = targets.length; _i < _len; _i++) {
            target = targets[_i];
            if (target.attributeGroupsForKey(key).length > 1) {
              allHaveJustThisGroupAsAttributeForKey = false;
              break;
            }
          }
          if (allHaveJustThisGroupAsAttributeForKey) {
            result.push({
              text: 'Hide this attribute',
              onclick: function() {
                var doIt, numPremises, warnings;
                doIt = function() {
                  return tinymce.activeEditor.undoManager.transact(function() {
                    var index, last, _j, _len1, _results;
                    _results = [];
                    for (index = _j = 0, _len1 = targets.length; _j < _len1; index = ++_j) {
                      target = targets[index];
                      last = index === targets.length - 1;
                      target.embedAttribute(key, last);
                      if (!last) {
                        _results.push(group.connect(targets[index + 1]));
                      } else {
                        _results.push(void 0);
                      }
                    }
                    return _results;
                  });
                };
                warnings = '';
                if (targets.length > 1) {
                  warnings += "You are hiding this attribute in " + targets.length + " expressions.  ";
                }
                numPremises = (group.attributionAncestry(true)).length - (group.attributionAncestry(false)).length;
                if (numPremises > 0) {
                  warnings += "There are " + numPremises + " premise connections that will be broken if you hide that attribute.  ";
                }
                if (warnings.length > 0) {
                  return tinymce.activeEditor.Dialogs.confirm({
                    title: 'Warning',
                    message: "" + warnings + "Continue anyway?",
                    okCallback: doIt
                  });
                } else {
                  return doIt();
                }
              }
            });
          } else if (targets.length === 1) {
            target = targets[0];
            sources = target.attributeGroupsForKey(key);
            anySourceModifiesAnotherGroup = false;
            for (_j = 0, _len1 = sources.length; _j < _len1; _j++) {
              source = sources[_j];
              if (source.connectionsOut().length > 1) {
                anySourceModifiesAnotherGroup = true;
                break;
              }
            }
            if (!anySourceModifiesAnotherGroup) {
              result.push({
                text: 'Hide this attribute',
                onclick: function() {
                  var doIt, numPremises, warnings, _k, _len2;
                  doIt = function() {
                    return tinymce.activeEditor.undoManager.transact(function() {
                      var index, last, _k, _len2, _results;
                      _results = [];
                      for (index = _k = 0, _len2 = targets.length; _k < _len2; index = ++_k) {
                        target = targets[index];
                        last = index === targets.length - 1;
                        target.embedAttribute(key, last);
                        if (!last) {
                          _results.push(group.connect(targets[index + 1]));
                        } else {
                          _results.push(void 0);
                        }
                      }
                      return _results;
                    });
                  };
                  warnings = "You are about to hide not one attribute, but " + sources.length + ", all of type " + key + ".  ";
                  numPremises = 0;
                  for (_k = 0, _len2 = sources.length; _k < _len2; _k++) {
                    source = sources[_k];
                    numPremises += (source.attributionAncestry(true)).length - (source.attributionAncestry(false)).length;
                  }
                  if (numPremises > 0) {
                    warnings += "There are " + numPremises + " premise connections that will be broken if you hide that attribute.  ";
                  }
                  if (warnings.length > 0) {
                    return tinymce.activeEditor.Dialogs.confirm({
                      title: 'Warning',
                      message: "" + warnings + "Continue anyway?",
                      okCallback: doIt
                    });
                  } else {
                    return doIt();
                  }
                }
              });
            }
          }
        }
        result.push({
          text: 'Attributes...',
          onclick: window.attributesActionForGroup(group)
        });
        return result;
      }
    }
  ];

  changeAttributeAction = function(group) {
    return {
      text: 'Change attribute key to...',
      menu: [
        {
          text: 'Label',
          onclick: function() {
            return tinymce.activeEditor.undoManager.transact(function() {
              return group.set('key', 'label');
            });
          }
        }, {
          text: 'Reason',
          onclick: function() {
            return tinymce.activeEditor.undoManager.transact(function() {
              return group.set('key', 'reason');
            });
          }
        }, {
          text: 'Premise',
          onclick: function() {
            return tinymce.activeEditor.undoManager.transact(function() {
              return group.set('key', 'premise');
            });
          }
        }, {
          text: 'Other...',
          onclick: function() {
            return tinymce.activeEditor.Dialogs.prompt({
              title: 'Enter new key',
              message: "Change \"" + (group.get('key')) + "\" to what?",
              okCallback: function(newKey) {
                if (!/^[a-zA-Z0-9-_]+$/.test(newKey)) {
                  tinymce.activeEditor.Dialogs.alert({
                    title: 'Invalid key',
                    message: 'Keys can only contain Roman letters, decimal digits, hyphens, and underscores (no spaces or other punctuation).',
                    width: 300,
                    height: 200
                  });
                  return;
                }
                return tinymce.activeEditor.undoManager.transact(function() {
                  return group.set('key', newKey);
                });
              }
            });
          }
        }
      ]
    };
  };

}).call(this);

//# sourceMappingURL=main-app-groups-solo.js.map
