// Generated by CoffeeScript 1.8.0
(function() {
  var Match, OM, OMNode, allBinaryFunctions, clearMetavariable, exports, isMetavariable, merge, metavariableSymbol, newVariableNotIn, setMetavariable, trueValue, udebug, unify, violatesCaptureConstraints, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof exports === "undefined" || exports === null) {
    exports = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : window;
  }

  if (typeof require !== "undefined" && require !== null) {
    _ref1 = require('./openmath-duo'), OM = _ref1.OM, OMNode = _ref1.OMNode;
  }

  metavariableSymbol = OM.symbol('metavariable', 'lurch');

  trueValue = OM.string('true');

  exports.setMetavariable = setMetavariable = function(variable) {
    var _ref2;
    if (!(variable instanceof OMNode) || ((_ref2 = variable.type) !== 'v' && _ref2 !== 'sy')) {
      return;
    }
    return variable.setAttribute(metavariableSymbol, trueValue.copy());
  };

  exports.clearMetavariable = clearMetavariable = function(metavariable) {
    return metavariable.removeAttribute(metavariableSymbol);
  };

  exports.isMetavariable = isMetavariable = function(variable) {
    var _ref2, _ref3;
    return variable instanceof OMNode && ((_ref2 = variable.type) === 'v' || _ref2 === 'sy') && ((_ref3 = variable.getAttribute(metavariableSymbol)) != null ? _ref3.equals(trueValue) : void 0);
  };

  exports.Match = Match = (function() {
    function _Class() {
      this.toString = __bind(this.toString, this);
      this.copy = __bind(this.copy, this);
      this.applyTo = __bind(this.applyTo, this);
      this.keys = __bind(this.keys, this);
      this.has = __bind(this.has, this);
      this.clear = __bind(this.clear, this);
      this.get = __bind(this.get, this);
      this.set = __bind(this.set, this);
      this.map = {};
    }

    _Class.prototype.set = function(varOrSym, expr) {
      if (varOrSym.simpleEncode != null) {
        varOrSym = varOrSym.simpleEncode();
      }
      return this.map[varOrSym] = expr.copy();
    };

    _Class.prototype.get = function(varOrSym) {
      var _ref2;
      return this.map[(_ref2 = typeof varOrSym.simpleEncode === "function" ? varOrSym.simpleEncode() : void 0) != null ? _ref2 : varOrSym];
    };

    _Class.prototype.clear = function(varOrSym) {
      var _ref2;
      varOrSym = (_ref2 = typeof varOrSym.simpleEncode === "function" ? varOrSym.simpleEncode() : void 0) != null ? _ref2 : varOrSym;
      return delete this.map[varOrSym];
    };

    _Class.prototype.has = function(varOrSym) {
      var _ref2;
      return this.map.hasOwnProperty((_ref2 = typeof varOrSym.simpleEncode === "function" ? varOrSym.simpleEncode() : void 0) != null ? _ref2 : varOrSym);
    };

    _Class.prototype.keys = function() {
      return Object.keys(this.map);
    };

    _Class.prototype.applyTo = function(pattern) {
      var metavariable, result, _i, _len, _ref2;
      result = pattern.copy();
      _ref2 = result.descendantsSatisfying(isMetavariable);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        metavariable = _ref2[_i];
        if (this.has(metavariable)) {
          metavariable.replaceWith(this.get(metavariable).copy());
        }
      }
      return result;
    };

    _Class.expressionFunction = OM.symbol('EF', 'lurch');

    _Class.expressionFunctionApplication = OM.symbol('EFA', 'lurch');

    _Class.makeExpressionFunction = function(input, body) {
      if (input.type !== 'v') {
        throw 'When creating an expression function, its parameter must be a variable';
      }
      return OM.bin(_Class.expressionFunction, input, body);
    };

    _Class.isExpressionFunction = function(expr) {
      return expr.type === 'bi' && expr.variables.length === 1 && expr.symbol.equals(_Class.expressionFunction);
    };

    _Class.makeExpressionFunctionApplication = function(ef, arg) {
      return OM.app(_Class.expressionFunctionApplication, ef, arg);
    };

    _Class.isExpressionFunctionApplication = function(expr) {
      var c;
      c = expr.children;
      return expr.type === 'a' && c.length === 3 && c[0].equals(_Class.expressionFunctionApplication);
    };

    _Class.prototype.copy = function() {
      var key, result, value, _ref2;
      result = new Match;
      _ref2 = this.map;
      for (key in _ref2) {
        if (!__hasProp.call(_ref2, key)) continue;
        value = _ref2[key];
        result.map[key] = value.copy();
      }
      return result;
    };

    _Class.prototype.toString = function() {
      var key, result, value, _ref2, _ref3;
      result = '{';
      _ref3 = (_ref2 = this.map) != null ? _ref2 : {};
      for (key in _ref3) {
        if (!__hasProp.call(_ref3, key)) continue;
        value = _ref3[key];
        if (result.length > 1) {
          result += ',';
        }
        result += "" + key + ":" + (value.simpleEncode());
      }
      return result + '}';
    };

    return _Class;

  })();

  newVariableNotIn = function() {
    var expressions, index, varname, works;
    expressions = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    index = 0;
    varname = function() {
      return OM["var"]("v" + index);
    };
    works = function() {
      var a, expression, isBad, _i, _len;
      a = varname();
      isBad = function(node) {
        return node.equals(a, false);
      };
      for (_i = 0, _len = expressions.length; _i < _len; _i++) {
        expression = expressions[_i];
        if (expression.hasDescendantSatisfying(isBad)) {
          return false;
        }
      }
      return true;
    };
    while (!works()) {
      index++;
    }
    return varname();
  };

  exports.debugOn = false;

  udebug = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (exports.debugOn) {
      return console.log.apply(console, args);
    }
  };

  exports.unify = unify = function(pattern, expression, solution) {
    var E, Eprime, F, MR, N, P, Q, S, addConstraint, anotherStartingWithF, body, c, constraint, ec, first, i, index, isF, isV, mergeResults, newVariable, newsolutions, nonSubstForms, p, pc, problemsToSolve, s, v, value, vprime, _i, _j, _k, _l, _len, _len1, _len2, _ref2, _ref3, _ref4, _ref5, _ref6;
    if (solution == null) {
      solution = new Match;
    }
    udebug('\nunify', pattern.simpleEncode(), expression.simpleEncode());
    if (expression.hasDescendantSatisfying(isMetavariable)) {
      throw 'Unifier rejects expressions containing metavariables';
    }
    newVariable = function() {
      return newVariableNotIn(pattern, expression);
    };
    problemsToSolve = [
      {
        constraints: [
          {
            pattern: pattern,
            expression: expression
          }
        ],
        solution: solution
      }
    ];
    while (true) {
      i = 0;
      while (i < problemsToSolve.length && problemsToSolve[i].constraints.length === 0) {
        i++;
      }
      udebug('\tloop', i, 'in', ((function() {
        var _i, _len, _ref2, _results;
        _results = [];
        for (_i = 0, _len = problemsToSolve.length; _i < _len; _i++) {
          P = problemsToSolve[_i];
          _results.push('' + ((function() {
            var _j, _len1, _ref2, _ref3, _ref4, _results1;
            _ref2 = P.constraints;
            _results1 = [];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              c = _ref2[_j];
              _results1.push("(" + ((_ref3 = c.pattern) != null ? _ref3.simpleEncode() : void 0) + "," + ((_ref4 = c.expression) != null ? _ref4.simpleEncode() : void 0) + ")");
            }
            return _results1;
          })()) + ((_ref2 = P.solution) != null ? _ref2.toString() : void 0));
        }
        return _results;
      })()).join(' ; '));
      if (i >= problemsToSolve.length) {
        udebug('\tabout to check constraints and return solutions');
        for (_i = 0, _len = problemsToSolve.length; _i < _len; _i++) {
          p = problemsToSolve[_i];
          udebug('\t\twould', pattern.simpleEncode(), 'and', (_ref2 = p.solution) != null ? _ref2.toString() : void 0, 'violate capture constraints?', (p.solution ? violatesCaptureConstraints(pattern, p.solution) : 'N/A'));
        }
        return (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = problemsToSolve.length; _j < _len1; _j++) {
            p = problemsToSolve[_j];
            if (p.solution !== null && !violatesCaptureConstraints(pattern, p.solution)) {
              _results.push(p.solution);
            }
          }
          return _results;
        })();
      }
      Q = problemsToSolve[i];
      first = Q.constraints.shift();
      P = first.pattern;
      E = first.expression;
      S = Q.solution;
      addConstraint = function(pushOrUnshift, pat, exp) {
        var constraint, _j, _len1, _ref3;
        if (pushOrUnshift !== 'push' && pushOrUnshift !== 'unshift') {
          return;
        }
        _ref3 = Q.constraints;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          constraint = _ref3[_j];
          if (constraint.pattern.equals(pat) && constraint.expression.equals(exp)) {
            return;
          }
        }
        return Q.constraints[pushOrUnshift]({
          pattern: pat,
          expression: exp
        });
      };
      if (((_ref3 = P.type) !== 'a' && _ref3 !== 'bi' && _ref3 !== 'e') && !isMetavariable(P)) {
        if (!P.equals(E, false)) {
          Q.constraints = [];
          Q.solution = null;
        }
        continue;
      }
      if (isMetavariable(P)) {
        if (S.has(P)) {
          addConstraint('push', S.get(P), E);
        } else {
          S.set(P, E);
        }
        continue;
      }
      if (P.type === 'bi') {
        pc = [P.symbol].concat(__slice.call(P.variables), [P.body]);
        ec = [E.symbol].concat(__slice.call(E.variables), [E.body]);
      } else {
        pc = P.children;
        ec = E.children;
      }
      if (!Match.isExpressionFunctionApplication(P)) {
        if (P.type !== E.type || pc.length !== ec.length) {
          Q.constraints = [];
          Q.solution = null;
        } else {
          for (index = _j = _ref4 = pc.length - 1; _ref4 <= 0 ? _j <= 0 : _j >= 0; index = _ref4 <= 0 ? ++_j : --_j) {
            addConstraint('unshift', pc[index], ec[index]);
          }
        }
        continue;
      }
      F = pc[1];
      v = pc[2];
      if (!isMetavariable(F)) {
        throw 'First argument to an expression function must be a metavariable';
      }
      nonSubstForms = (function() {
        var _k, _len1, _ref5, _results;
        _ref5 = Q.constraints;
        _results = [];
        for (_k = 0, _len1 = _ref5.length; _k < _len1; _k++) {
          c = _ref5[_k];
          if (!Match.isExpressionFunctionApplication(c.pattern)) {
            _results.push(c);
          }
        }
        return _results;
      })();
      if (nonSubstForms.length > 0) {
        udebug('\t\tdelaying substitution forms...');
        addConstraint('push', P, E);
        continue;
      }
      if (S.has(F)) {
        udebug('\t\tthe ef is in the solution set');
        body = S.get(F).body.copy();
        body.replaceFree(S.get(F).variables[0], v);
        addConstraint('unshift', body, E);
        continue;
      }
      _ref5 = Q.constraints;
      for (_k = 0, _len1 = _ref5.length; _k < _len1; _k++) {
        constraint = _ref5[_k];
        isV = function(node) {
          return node.equals(v);
        };
        isF = function(node) {
          return node.equals(F);
        };
        if (constraint.pattern.hasDescendantSatisfying(isV) && !constraint.pattern.hasDescendantSatisfying(isF)) {
          throw 'Parameter of one function application appears in another function application; this level of complexity is not supported by this unification algorithm.';
        }
      }
      anotherStartingWithF = -1;
      _ref6 = Q.constraints;
      for (index = _l = 0, _len2 = _ref6.length; _l < _len2; index = ++_l) {
        constraint = _ref6[index];
        if (Match.isExpressionFunctionApplication(constraint.pattern) && constraint.pattern.children[1].equals(F)) {
          anotherStartingWithF = index;
          break;
        }
      }
      if (anotherStartingWithF === -1) {
        N = newVariable();
        if (!S.has(v)) {
          S.set(F, Match.makeExpressionFunction(N, N));
          S.set(v, E);
          udebug('\t\t1 constraint w/this func, v known');
        } else {
          value = S.get(v);
          udebug('\t\texponential explosion w/v', value.simpleEncode(), 'and E', E.simpleEncode());
          newsolutions = allBinaryFunctions(E, value, N, S, F);
          problemsToSolve.splice.apply(problemsToSolve, [i, 1].concat(__slice.call((function() {
            var _len3, _m, _results;
            _results = [];
            for (_m = 0, _len3 = newsolutions.length; _m < _len3; _m++) {
              s = newsolutions[_m];
              _results.push({
                constraints: Q.constraints.slice(0),
                solution: s
              });
            }
            return _results;
          })())));
        }
        continue;
      }
      vprime = Q.constraints[anotherStartingWithF].pattern.children[2];
      Eprime = Q.constraints[anotherStartingWithF].expression;
      Q.constraints.splice(anotherStartingWithF, 1);
      mergeResults = merge(F, E, Eprime, v, vprime, S);
      problemsToSolve.splice.apply(problemsToSolve, [i, 1].concat(__slice.call((function() {
        var _len3, _m, _results;
        _results = [];
        for (_m = 0, _len3 = mergeResults.length; _m < _len3; _m++) {
          MR = mergeResults[_m];
          _results.push({
            constraints: Q.constraints.slice(0),
            solution: MR.copy()
          });
        }
        return _results;
      })())));
      udebug('\t\tmerging with index', anotherStartingWithF);
    }
  };

  merge = function(F, E, Eprime, v, vprime, S) {
    var Fofv, Fofvprime, N, address, asString, body, d, difference, differences, findDifferencesBetween, func, known, lhs, newDifferences, newDifferencesAsStrings, newVariable, newsols, parameter, rhs, s, shorter, sol, solution, solutions, terminateTheLoop, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref2, _ref3, _ref4, _ref5, _ref6;
    udebug('\nmerge F:', F.simpleEncode(), ', E:', E.simpleEncode(), ', E\':', Eprime.simpleEncode(), ', v:', v.simpleEncode(), ', v\':', vprime.simpleEncode(), ', S:', S.toString());
    newVariable = function() {
      return newVariableNotIn(F, E, Eprime, v, vprime);
    };
    if (E.hasDescendantSatisfying(Match.isExpressionFunctionApplication) || Eprime.hasDescendantSatisfying(Match.isExpressionFunctionApplication)) {
      throw 'The merge algorithm does not support expressions containing applications of expression functions.';
    }
    differences = [];
    findDifferencesBetween = function(A, B) {
      var Ac, Bc, c, child, index, _i, _len, _results;
      udebug('\t\t\tdiff', A.simpleEncode(), A.address(E), B.simpleEncode(), B.address(Eprime));
      if (A.type !== B.type) {
        udebug('\t\t\ttypes diff;', A.address(E));
        differences.push(A.address(E));
        return;
      }
      if (A.type === 'bi') {
        Ac = [A.symbol].concat(__slice.call(A.variables), [A.body]);
        Bc = [B.symbol].concat(__slice.call(B.variables), [B.body]);
      } else {
        Ac = A.children;
        Bc = B.children;
      }
      udebug('\t\t\tchildren:', ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = Ac.length; _i < _len; _i++) {
          c = Ac[_i];
          _results.push(c.simpleEncode());
        }
        return _results;
      })()).join(','), ';', ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = Bc.length; _i < _len; _i++) {
          c = Bc[_i];
          _results.push(c.simpleEncode());
        }
        return _results;
      })()).join(','));
      if (Ac.length !== Bc.length || (Ac.length + Bc.length === 0 && !A.equals(B, false))) {
        udebug('\t\t\tnon-recursive difference;', A.address(E));
        return differences.push(A.address(E));
      } else {
        _results = [];
        for (index = _i = 0, _len = Ac.length; _i < _len; index = ++_i) {
          child = Ac[index];
          _results.push(findDifferencesBetween(child, Bc[index]));
        }
        return _results;
      }
    };
    findDifferencesBetween(E, Eprime);
    if (differences.length === 0) {
      udebug('\tno differences!');
      known = function(x) {
        return !isMetavariable(x) || S.has(x);
      };
      value = function(x) {
        if (!isMetavariable(x)) {
          return x;
        } else {
          return S.get(x);
        }
      };
      udebug('\t\tv known?', known(v), 'value', (_ref2 = value(v)) != null ? _ref2.simpleEncode() : void 0, 'v\' known?', known(vprime), 'value', (_ref3 = value(vprime)) != null ? _ref3.simpleEncode() : void 0);
      N = newVariable();
      if (known(v) && known(vprime)) {
        if (!value(v).equals(value(vprime))) {
          S.set(F, Match.makeExpressionFunction(N, E));
          return [S];
        } else {
          return allBinaryFunctions(E, value(v), N, S, F);
        }
      } else if (known(v)) {
        newsols = allBinaryFunctions(E, value(v), N, S, F);
        _ref4 = newsols.slice(1);
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          sol = _ref4[_i];
          sol.set(vprime, value(v));
        }
        udebug('\t\tknown/unknown result:', ((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = newsols.length; _j < _len1; _j++) {
            s = newsols[_j];
            _results.push(s.toString());
          }
          return _results;
        })()).join(' ; '));
        return newsols;
      } else if (known(vprime)) {
        newsols = allBinaryFunctions(E, value(vprime), N, S, F);
        _ref5 = newsols.slice(1);
        for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
          sol = _ref5[_j];
          sol.set(v, value(vprime));
        }
        udebug('\t\tunknown/known result:', ((function() {
          var _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = newsols.length; _k < _len2; _k++) {
            s = newsols[_k];
            _results.push(s.toString());
          }
          return _results;
        })()).join(' ; '));
        return newsols;
      } else {
        S.set(F, Match.makeExpressionFunction(N, E));
        return [S];
      }
    }
    solutions = [];
    while (true) {
      udebug('\tdifferences: [', ((function() {
        var _k, _len2, _results;
        _results = [];
        for (_k = 0, _len2 = differences.length; _k < _len2; _k++) {
          d = differences[_k];
          _results.push("[" + d + "]");
        }
        return _results;
      })()).join(' ; '), ']');
      udebug('\t\trecursively calling unify...');
      parameter = newVariable();
      body = E.copy();
      for (_k = 0, _len2 = differences.length; _k < _len2; _k++) {
        address = differences[_k];
        body.index(address).replaceWith(parameter.copy());
      }
      func = Match.makeExpressionFunction(parameter, body);
      Fofv = body.copy();
      Fofv.replaceFree(parameter, v);
      Fofvprime = body.copy();
      Fofvprime.replaceFree(parameter, vprime);
      lhs = OM.app(Fofv, Fofvprime);
      rhs = OM.app(E, Eprime);
      udebug('\t\t\tfunc', func.simpleEncode());
      udebug('\t\t\tF(v)', Fofv.simpleEncode(), 'F(v\')', Fofvprime.simpleEncode());
      udebug('\t\t\tE', E.simpleEncode(), 'E\'', Eprime.simpleEncode());
      _ref6 = unify(lhs, rhs, S.copy());
      for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
        solution = _ref6[_l];
        solution.set(F, func);
        solutions.push(solution);
      }
      udebug('\t\tafter recursion, extended solutions:');
      udebug('\t\t', ((function() {
        var _len4, _m, _results;
        _results = [];
        for (_m = 0, _len4 = solutions.length; _m < _len4; _m++) {
          s = solutions[_m];
          _results.push(s.toString());
        }
        return _results;
      })()).join(' ; '));
      newDifferences = [];
      newDifferencesAsStrings = [];
      terminateTheLoop = false;
      for (_m = 0, _len4 = differences.length; _m < _len4; _m++) {
        difference = differences[_m];
        if (difference.length === 0) {
          terminateTheLoop = true;
          break;
        }
        shorter = difference.slice(0, -1);
        asString = "" + shorter;
        if (__indexOf.call(newDifferencesAsStrings, asString) < 0) {
          newDifferences.push(shorter);
          newDifferencesAsStrings.push(asString);
        }
      }
      if (terminateTheLoop) {
        break;
      }
      differences = newDifferences;
    }
    udebug('\tfinishing merge with these solutions:');
    udebug('\t\t', ((function() {
      var _len5, _n, _results;
      _results = [];
      for (_n = 0, _len5 = solutions.length; _n < _len5; _n++) {
        s = solutions[_n];
        _results.push(s.toString());
      }
      return _results;
    })()).join(' ; '));
    return solutions;
  };

  violatesCaptureConstraints = function(pattern, solution, boundVars) {
    var child, freeVarName, moreBoundVars, variable, _i, _j, _len, _len1, _ref2, _ref3;
    if (boundVars == null) {
      boundVars = [];
    }
    if (isMetavariable(pattern)) {
      _ref2 = solution.get(pattern).freeVariables();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        freeVarName = _ref2[_i];
        if (__indexOf.call(boundVars, freeVarName) >= 0) {
          return true;
        }
      }
      return false;
    } else if (pattern.type === 'bi') {
      moreBoundVars = (function() {
        var _j, _len1, _ref3, _results;
        _ref3 = pattern.variables;
        _results = [];
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          variable = _ref3[_j];
          if (isMetavariable(variable)) {
            _results.push(solution.get(variable).name);
          } else {
            _results.push(variable.name);
          }
        }
        return _results;
      })();
      return violatesCaptureConstraints(pattern.body, solution, boundVars.concat(moreBoundVars));
    } else if (Match.isExpressionFunctionApplication(pattern)) {
      return violatesCaptureConstraints(pattern.children[1], solution, boundVars);
    } else {
      _ref3 = pattern.children;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        child = _ref3[_j];
        if (violatesCaptureConstraints(child, solution, boundVars)) {
          return true;
        }
      }
      return false;
    }
  };

  allBinaryFunctions = function(expr, subexpr, variable, S, E) {
    var addresses, bits, body, i, newsol, subexpression, _i, _j, _ref2, _ref3, _results;
    addresses = (function() {
      var _i, _len, _ref2, _results;
      _ref2 = expr.descendantsSatisfying(function(node) {
        return node.equals(subexpr);
      });
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        subexpression = _ref2[_i];
        _results.push(subexpression.address(expr));
      }
      return _results;
    })();
    if (addresses.length > 4) {
      throw 'Problem size growing too large for the unification algorithm';
    }
    _results = [];
    for (bits = _i = 0, _ref2 = 1 << addresses.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; bits = 0 <= _ref2 ? ++_i : --_i) {
      body = expr.copy();
      newsol = S.copy();
      for (i = _j = 0, _ref3 = addresses.length; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
        if (bits & (1 << i)) {
          body.index(addresses[i]).replaceWith(variable.copy());
        }
      }
      newsol.set(E, Match.makeExpressionFunction(variable, body));
      _results.push(newsol);
    }
    return _results;
  };

}).call(this);

//# sourceMappingURL=unification-duo.js.map
